{"meta":{"title":"XIAOHU blog","subtitle":"Welcome to my blog","description":"愿你走出半生路 归来仍是少年","author":"XIAOHU","url":"http://yoursite.com","root":"/"},"pages":[{"title":"文章分类","date":"2017-05-27T05:47:40.000Z","updated":"2020-03-02T08:14:54.853Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2017-05-27T05:47:40.000Z","updated":"2020-03-02T07:19:57.631Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"那些年我踩过的坑","slug":"cai","date":"2020-03-16T07:04:05.000Z","updated":"2020-03-16T07:25:57.015Z","comments":true,"path":"2020/03/16/cai/","link":"","permalink":"http://yoursite.com/2020/03/16/cai/","excerpt":"","text":"最近这两天，由于切实的感觉到gitalk评论系统实在是太慢了，就想换一个。 由于 来必力（LiveRe） Disqus 和gitalk一个德性 加载速度贼慢，甚至有被墙的可能，寻觅了很久之后， 选择了valine系统。 然后，经过一番常规操作之后，在加载上valine之后，疯狂报错。 如下图 此处的我默默的流下伤心的泪水。 然而经过我翻墙后在谷歌坚持不懈地寻找，最后终于找到了解决方法。 右键检查发现 这该死的，居然把注释也给获取了。找到主题下的_config.yml，删掉注释重新部署就可以完成了 。 如果还没解决的话可以试试切换leancloud节点，我这里是华北节点，创建class 。","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"http://yoursite.com/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"spring之数据库增删改查","slug":"article8","date":"2020-03-15T13:05:55.000Z","updated":"2020-03-15T13:36:05.630Z","comments":true,"path":"2020/03/15/article8/","link":"","permalink":"http://yoursite.com/2020/03/15/article8/","excerpt":"","text":"基于junit和mysql的spring开发1.持久层实现类java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.dao.impl;import com.dao.IAccountDao;import com.domain.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.SQLException;import java.util.List;//账户持久层实现类public class AccountDaoImpl implements IAccountDao { private QueryRunner runner; public void setRunner(QueryRunner runner) { this.runner = runner; } public List findAllAccount() { try { return runner.query(\"select * from account\",new BeanListHandler(Account.class)); } catch (SQLException e) { throw new RuntimeException(e); } } public Account findAccountById(Integer accountId) { try { return runner.query(\"select * from account where id = ? \",new BeanHandler(Account.class),accountId); } catch (SQLException e) { throw new RuntimeException(e); } } public void saveAccount(Account account) { try { runner.update(\"insert into account(name,money) values(?,?)\",account.getName(),account.getMoney()); } catch (SQLException e) { throw new RuntimeException(e); } } public void updateAccount(Account account) { try { runner.update(\"update account set name=?,money=? where id=?\",account.getName(),account.getMoney(),account.getId()); }catch (SQLException e) { throw new RuntimeException(e); } } public void deleteAccount(Integer accountId) { try { runner.update(\"delete from account where id = ?\",accountId); }catch (SQLException e) { throw new RuntimeException(e); } }} 2.账户类pgsql123456789101112131415161718192021222324252627282930313233343536373839404142package com.domain;import java.io.Serializable;public class Account implements Serializable { private Integer id; private String name; private Float money; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Float getMoney() { return money; } public void setMoney(Float money) { this.money = money; } @Override public String toString() { return \"Account{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", money=\" + money + '}'; }} 3.业务层实现类aspectj1234567891011121314151617181920212223242526272829303132333435363738package com.service.impl;import com.dao.IAccountDao;import com.domain.Account;import com.service.IAccountService;import java.util.List;//账户业务层实现类public class AccountServiceImpl implements IAccountService { private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) { this.accountDao = accountDao; } public List findAllAccount() { return accountDao.findAllAccount(); } public Account findAccountById(Integer accountId) { return accountDao.findAccountById(accountId); } public void saveAccount(Account account) { accountDao.saveAccount(account); } public void updateAccount(Account account) { accountDao.updateAccount(account); } public void deleteAccount(Integer accountId) { accountDao.deleteAccount(accountId); }} 4.bean.xml创建bean和数据库驱动 applescript1234567891011121314151617181920212223242526version=\"1.0\" encoding=\"UTF-8\"?>\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> property> property> -- 配置QueryRunner--> -- 注入数据源--> -- 配置数据源--> property> property> property> property> 4.junit实现的测试类reasonml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.test;import com.domain.Account;import com.service.IAccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;//使用junit单元测试public class AccountServioceTest { @Test public void testFindAll() {// 1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 List accountcs = as.findAllAccount(); for (Account account : accountcs){ System.out.println(account); } } @Test public void testFindOne() { // 1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 Account account =as.findAccountById(1); System.out.println(account); } @Test public void testSave() { Account account =new Account(); account.setName(\"test\"); account.setMoney(12345f); ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 as.saveAccount(account);// System.out.println(account); } @Test public void testUpdate() { ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 Account account = as.findAccountById(4); account.setMoney(23456f); as.updateAccount(account); } @Test public void testDelete() { ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 as.deleteAccount(4); }} 5.设置导入包的坐标–pom.xmlxml12345678910111213141516171819202122232425262728293031323334353637383940 4.0.0modelVersion> org.examplegroupId> springday02_02artifactId> 1.0-SNAPSHOTversion> jarpackaging> org.springframeworkgroupId> spring-contextartifactId> 5.0.2.RELEASEversion> dependency> commons-dbutilsgroupId> commons-dbutilsartifactId> 1.4version> dependency> mysqlgroupId> mysql-connector-javaartifactId> 8.0.19version> dependency> c3p0groupId> c3p0artifactId> 0.9.1.2version> dependency> junitgroupId> junitartifactId> 4.10version> dependency> dependencies>project>","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"三层架构","slug":"三层架构","permalink":"http://yoursite.com/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"}]},{"title":"spring之注解配置","slug":"article7","date":"2020-03-15T11:50:50.000Z","updated":"2020-03-15T13:02:37.804Z","comments":true,"path":"2020/03/15/article7/","link":"","permalink":"http://yoursite.com/2020/03/15/article7/","excerpt":"","text":"1.基于注解配置的bean.xml的约束条件xml1234567891011121314 依赖中需要aop的jar包 告知spring在创建容器需要的包，配置标签在context的名称空间和约束中 context:component-scan>beans> 2.注解配置创建Bean加入Ioc容器*曾经XML的配置：monkey12345* \"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"* scope=\"\" init-method=\"\" destroy-method=\"\">* property>* *使用注解配置1.用于创建对象的stata123456789101112131415161718192021222324252627282930 * 他们的作用就和在XML配置文件中编写一个标签实现的功能是一样的 * Component: * 作用：用于把当前类对象存入spring容器中 * 属性： * value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。 * Controller：一般用在表现层 * Service：一般用在业务层 * Repository：一般用在持久层 * 以上三个注解他们的作用和属性与Component是一模一样。 * 他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰 *package com.itheima.dao.impl;import com.itheima.dao.IAccountDao;import org.springframework.stereotype.Repository;/** * 账户的持久层实现类 */@Repository(\"accountDao1\")public class AccountDaoImpl implements IAccountDao { public void saveAccount(){ System.out.println(\"保存了账户1111111111111\"); }} 2.用于注入数据的gams1234567891011121314151617181920212223242526* 他们的作用就和在xml配置文件中的bean标签中写一个标签的作用是一样的* Autowired:* 作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功* 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。* 如果Ioc容器中有多个类型匹配时：* 出现位置：* 可以是变量上，也可以是方法上* 细节：* 在使用注解注入时，set方法就不是必须的了。* Qualifier:* 作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以* 属性：* value：用于指定注入bean的id。* Resource* 作用：直接按照bean的id注入。它可以独立使用* 属性：* name：用于指定bean的id。* 以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。* 另外，集合类型的注入只能通过XML来实现。** Value* 作用：用于注入基本类型和String类型的数据* 属性：* value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式）* SpEL的写法：${表达式}* 3.用于改变作用范围的asciidoc123456789101112* 他们的作用就和在bean标签中使用scope属性实现的功能是一样的* Scope* 作用：用于指定bean的作用范围* 属性：* value：指定范围的取值。常用取值：singleton prototype** 和生命周期相关 了解* 他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的* PreDestroy* 作用：用于指定销毁方法* PostConstruct* 作用：用于指定初始化方法 3.业务层代码实现crystal12345678910111213141516171819202122232425262728293031323334353637package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.service.IAccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;import javax.annotation.Resource;@Component//@Service(\"accountService\")//@Scope(\"prototype\")public class AccountServiceImpl implements IAccountService {// @Autowired// @Qualifier(\"accountDao1\") @Resource(name = \"accountDao2\") private IAccountDao accountDao = null; @PostConstruct public void init(){ System.out.println(\"初始化方法执行了\"); } @PreDestroy public void destroy(){ System.out.println(\"销毁方法执行了\"); } public void saveAccount(){ accountDao.saveAccount(); }} 4.创建容器调用业务层pgsql1234567891011121314151617181920212223242526272829package com.itheima.ui;import com.itheima.dao.IAccountDao;import com.itheima.service.IAccountService;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 模拟一个表现层，用于调用业务层 */public class Client { /** * @param args */ public static void main(String[] args) { //1.获取核心容器对象// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取Bean对象 IAccountService as = (IAccountService)ac.getBean(\"accountServiceImpl\");// IAccountService as2 = (IAccountService)ac.getBean(\"accountService\"); System.out.println(as);// IAccountDao adao = ac.getBean(\"accountDao\",IAccountDao.class);// System.out.println(adao);// System.out.println(as == as2); as.saveAccount(); ac.close(); }}","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"JDBC入门","slug":"article6","date":"2020-03-13T05:33:07.000Z","updated":"2020-03-13T06:49:49.974Z","comments":true,"path":"2020/03/13/article6/","link":"","permalink":"http://yoursite.com/2020/03/13/article6/","excerpt":"","text":"1. JDBC基本概念 2. JDBC基本使用 3. 对JDBC中各个接口和类详解JDBC：1. 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 2. 快速入门： * 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql 5. 获取执行sql语句的对象 Statement 6. 执行sql，接受返回结果 7. 处理结果 8. 释放资源 * 代码实现： //1. 导入驱动jar包 //2.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/shopping?useUnicode=true&characterEncoding=utf8\",\"root\",\"****\"); //4.定义sql语句 String sql = \"update account set balance = 500 where id = 1\"; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); 3. 详解各个对象： 1. DriverManager：驱动管理对象 * 功能： 1. 注册驱动：告诉程序该使用哪一个数据库驱动jar static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(\"com.mysql.jdbc.Driver\"); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(\"Can't register driver!\"); } } 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2. 获取数据库连接： * 方法：static Connection getConnection(String url, String user, String password) * 参数： * url：指定连接的路径 * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称?useUnicode=true&characterEncoding=utf8 * 例子：jdbc:mysql://localhost:3306/shopping?useUnicode=true&characterEncoding=utf8 * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 * user：用户名 * password：密码 2. Connection：数据库连接对象 1. 功能： 1. 获取执行sql 的对象 * Statement createStatement() * PreparedStatement prepareStatement(String sql) 2. 管理事务： * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 提交事务：commit() * 回滚事务：rollback() 3. Statement：执行sql的对象 1. 执行sql 1. boolean execute(String sql) ：可以执行任意的sql 了解 2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值>0的则执行成功，反之，则失败。 3. ResultSet executeQuery(String sql) ：执行DQL（select)语句 2. 练习： package cn; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Statement; public class jdbc2 { public static void main(String[] args) { Statement stmt = null; Connection conn =null; // 1.注册驱动 try { Class.forName(\"com.mysql.jdbc.Driver\"); // 2.定义sql // INSERT INTO `items` VALUES ('1', '沃特篮球鞋', '佛山', '180', '500', '001.jpg'); String sql = \"INSERT INTO `items` VALUES ('11', '篮球鞋', '佛山', '180', '500', '011.jpg')\"; // 获取connection对象 conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/shopping?useUnicode=true&characterEncoding=utf8\",\"root\",\"123456\"); // 4.获取执行sql对象 stmt = conn.createStatement(); // 5.执行sql int count = stmt.executeUpdate(sql); System.out.println(count); if (count>0) System.out.println(\"添加成功\"); } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { // 避免空指针异常 if (stmt!=null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } 4. ResultSet：结果集对象,封装查询结果 * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true * getXxx(参数):获取数据 * Xxx：代表数据类型 如： int getInt() , String getString() * 参数： 1. int：代表列的编号,从1开始 如： getString(1) 2. String：代表列名称。 如： getDouble(\"balance\") * 注意： * 使用步骤： 1. 游标向下移动一行 2. 判断是否有数据 3. 获取数据 //循环判断游标是否是最后一行末尾。 while(rs.next()){ //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(\"name\"); double balance = rs.getDouble(3); System.out.println(id + \"---\" + name + \"---\" + balance); } 5. PreparedStatement：执行sql的对象(使用较多) 1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 1. 输入用户随便，输入密码：a' or 'a' = 'a 2. sql：select * from user where username = 'fhdsjkf' and password = 'a' or 'a' = 'a' 2. 解决sql注入问题：使用PreparedStatement对象来解决 3. 预编译的SQL：参数使用?作为占位符 4. 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 5. 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 6. 给？赋值： * 方法： setXxx(参数1,参数2) * 参数1：？的位置编号 从1 开始 * 参数2：？的值 7. 执行sql，接受返回结果，不需要传递sql语句 8. 处理结果 9. 释放资源 案例代码: /** * 练习：jdbc+jdbcutils+mysql * * 需求： * 1. 通过键盘录入用户名和密码 * 2. 判断用户是否登录成功 */ package cn.itcast.jdbc; import cn.itcast.util.JDBCUtils; import java.sql.*; import java.util.Scanner; public class JDBCDemo9 { public static void main(String[] args) { //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(\"请输入用户名：\"); String username = sc.nextLine(); System.out.println(\"请输入密码：\"); String password = sc.nextLine(); //2.调用方法 boolean flag = new JDBCDemo9().login2(username, password); //3.判断结果，输出不同语句 if(flag){ //登录成功 System.out.println(\"登录成功！\"); }else{ System.out.println(\"用户名或密码错误！\"); } } /** * 登录方法 */ public boolean login(String username ,String password){ if(username == null || password == null){ return false; } //连接数据库判断是否登录成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; //1.获取连接 try { conn = JDBCUtils.getConnection(); //2.定义sql String sql = \"select * from user where username = '\"+username+\"' and password = '\"+password+\"' \"; System.out.println(sql); //3.获取执行sql的对象 stmt = conn.createStatement(); //4.执行查询 rs = stmt.executeQuery(sql); //5.判断 /* if(rs.next()){//如果有下一行，则返回true return true; }else{ return false; }*/ return rs.next();//如果有下一行，则返回true } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,stmt,conn); } return false; }​ /** * 登录方法,使用PreparedStatement实现 */ public boolean login2(String username ,String password){ if(username == null || password == null){ return false; } //连接数据库判断是否登录成功 Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; //1.获取连接 try { conn = JDBCUtils.getConnection(); //2.定义sql String sql = \"select * from user where username = ? and password = ?\"; //3.获取执行sql的对象 pstmt = conn.prepareStatement(sql); //给?赋值 pstmt.setString(1,username); pstmt.setString(2,password); //4.执行查询,不需要传递sql rs = pstmt.executeQuery(); //5.判断 /* if(rs.next()){//如果有下一行，则返回true return true; }else{ return false; }*/ return rs.next();//如果有下一行，则返回true } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,pstmt,conn); } return false; } } ​​ 5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作​ 1. 可以防止SQL注入​ 2. 效率更高 抽取JDBC工具类 ： JDBCUtils* 目的：简化书写 * 分析： 1. 抽取注册驱动 2. 抽取一个方法获取连接对象 * 需求：不想传递参数（麻烦），还得保证工具类的通用性。 * 解决：配置文件 jdbc.properties url= user= password= 3. 抽取一个方法释放资源 package utils; import java.io.FileReader; import java.io.IOException; import java.net.URL; import java.sql.*; import java.util.Properties; public class jdbcutils { private static String url; private static String user; private static String password; private static String driver; static { // 读取资源文件获取值 // 1.Properties try { Properties pro =new Properties(); // 获取src路径下的方式 // ClassLoader classLoader = jdbcutils.class.getClassLoader(); // URL res = classLoader.getResource(\"jdbc.properties\"); // String path =res.getPath(); // System.out.println(path); // 2.加载文件 pro.load(new FileReader(\"src/jdbc.properties\")); // pro.load(new FileReader(path)); url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver =pro.getProperty(\"driver\"); Class.forName(driver); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } }​ ​ // 获取连接，返回连接对象 public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url,user,password); } // 释放资源 public static void close(Statement stmt,Connection conn){ if (stmt!=null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } public static void close(Statement stmt,Connection conn,ResultSet rs){ if (rs!=null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (stmt!=null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } }​ ​","categories":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/categories/jsp/"}],"tags":[{"name":"java工具类","slug":"java工具类","permalink":"http://yoursite.com/tags/java%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"title":"spring之依赖注入数据","slug":"article5","date":"2020-03-10T10:24:07.000Z","updated":"2020-03-15T11:48:14.619Z","comments":true,"path":"2020/03/10/article5/","link":"","permalink":"http://yoursite.com/2020/03/10/article5/","excerpt":"","text":"原本很认真的写，然而天有不测风云，更新个编辑器版本，我原本写的全没了，算了算了。 1.放在resource下的bean.xmlxquery123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154\"1.0\" encoding=\"UTF-8\"?>\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> 依赖注入: dependency injection Ioc的作用 降低程序的依赖 依赖关系的管理交给spring维护 在当前类需要用到其他类的对象，由spring提供，需要再配置文件说明 依赖注入: 能注入的数据，三类： 基本类型和string 其他bean类型（在配置文件或者注解配置过的bean） 复杂类型/集合类型 注入方式: 1.使用构造函数 2.使用set 3.使用注解提供 构造函数注入 使用constructor-arg type：用于注入的数据的数据类型 index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引的位置从0开始 name：用于指定给构造函数中制定名称的参数赋值 value：提供基本类型和string类型的数据 ref：用于指定其他的bean类型数据。 优势： 获取bean对象时，注入数据是必须的操作 弊端： 如果用不到这些数据，也必须提供。 constructor-arg> constructor-arg> constructor-arg> bean> bean> --set方法注入 name：用于指定注入时调用的set方法名称 value：提供基本类型和string类型的数据 ref：用于指定其他的bean类型数据。 优势： 创建对象没有明确的限制，可以直接用默认构造函数 弊端： 如果某个成员必须有值，则获取对象时set方法没有执行 property> property> property> bean> 集合类型注入 用于给list结构注入的标签由 list array set 用于给map结构集合注入 map props 结构相同，标签可以互换 AAAAAAvalue> bbbbvalue> ccccvalue> array> property> AAAAAAvalue> bbbbvalue> ccccvalue> list> property> AAAAAAvalue> bbbbvalue> ccccvalue> set> property> entry> entry> map> property> ccccprop> props> property> bean> --把对象的创建交给spring来管理-- --spring对bian的管理细节 1.创建bean的三种方式 2.bean的作用范围 3.bean的生命周期 --1.使用默认构造函数 使用bean标签，配以id和class属性之后，没有其他属性和标签时，采用的就是默认构造函数， 如果类中没有默认构造函数，则对象无法创建 bean>--> --2.使用工厂中的方法创建对象，或者使用某个类中的方法创建对象，并存入spring容器 bean> bean> --使用工厂中的静态方法创建对象 bean> bean的作用范围调整 bean标签的scope属性: 取值: singleton 单例(默认值) prototype 多例的 request 作用于web应用的请求范围 session 作用于web应用的会话范围 global-session 集群环境的会话范围(全局会话范围),当不是集群环境时，就是session --bean对象的生命周期 单例对象 生命周期和容器相同 多例对象 使用对象时候创建，只要是在使用过程中就一直活着， java垃圾回收器来进行回收 2.Client.javapgsql123456789101112131415161718192021222324252627282930313233343536package com.itheima.ui;//import com.itheima.dao.IAccountDao;import com.itheima.service.IAccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 模拟一个表现层，用于调用业务层 */public class Client { public static void main(String[] args) { //1.获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// ApplicationContext ac = new FileSystemXmlApplicationContext(\"C:\\\\Users\\\\zhy\\\\Desktop\\\\bean.xml\"); //2.根据id获取Bean对象// IAccountDao adao = ac.getBean(\"accountDao\",IAccountDao.class);// IAccountService as = (IAccountService)ac.getBean(\"accountService\");// as.saveAccount();// IAccountService as = (IAccountService)ac.getBean(\"accountService2\");// as.saveAccount(); IAccountService as = (IAccountService)ac.getBean(\"accountService3\"); as.saveAccount(); //--------BeanFactory----------// Resource resource = new ClassPathResource(\"bean.xml\");// BeanFactory factory = new XmlBeanFactory(resource);// IAccountService as = (IAccountService)factory.getBean(\"accountService\");// System.out.println(as); }}","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"浅谈http协议","slug":"article4","date":"2020-03-09T01:52:56.000Z","updated":"2020-03-15T11:47:20.236Z","comments":true,"path":"2020/03/09/article4/","link":"","permalink":"http://yoursite.com/2020/03/09/article4/","excerpt":"","text":"HTTP 超文本传输协议 Hyper Text Transfer Protocol 当我们在浏览器的地址栏输入一个地址的时候，就能够访问服务器的某个页面 这个过程本身就是两个应用程序之间的交互，一个应用程序是浏览器，另一个应用程序是服务器。 协议是什么？ 协议就是不同的应用程序之间按照事先做好的约定进行的通信。 这样就能互相读懂对方的意思。 浏览器和WEB服务器之间，使用的就是一种叫做HTTP的协议。 这样是BS (Browser Server )架构模型的基础 请求消息请求消息 由 请求行，请求头部，空行和请求数据4部分组成 1.请求行格式：请求方式 资源路径 HTTP版本号举例：GET/test.html HTTP/1.1请求方式：POST,HEAD,OPTIONS,DELETE,TRACE,PUT 2.请求头 请求头部信息提供了如下信息:Host: 主机名User-Agent: 浏览器基本资料Accept: 浏览器能够识别的响应类型Accept-Language: 浏览器默认语言Accept-Encoding: 浏览器能够识别的压缩方式Referer: 来路页面， /addHero 这个路径是通过addHero.html这个页面跳转过来的。Connecton：是否保持连接 3.请求数据​ post方法中，会把数据以key value形式发送请求 4.空行​ 发送回车符和换行符，通知服务器以下不再有请求头 响应消息响应信息由状态行，响应头，响应正文组成 1.状态行格式如下： HTTP-Version Status-Code Reason-Phrase CRLF 其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。 HTTP状态码当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。HTTP状态码的英文为HTTP Status Code。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 2.HTTP响应头响应头的方法 3.响应正文如图所示，在响应正文里就会是具体的html内容了。当然访问不同的页面，就不一定是html，有可能是css, js,甚至图片了。","categories":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/categories/jsp/"}],"tags":[{"name":"jsp开发","slug":"jsp开发","permalink":"http://yoursite.com/tags/jsp%E5%BC%80%E5%8F%91/"}]},{"title":"spring之获取容器","slug":"spring1","date":"2020-03-08T12:04:26.000Z","updated":"2020-03-15T11:49:50.317Z","comments":true,"path":"2020/03/08/spring1/","link":"","permalink":"http://yoursite.com/2020/03/08/spring1/","excerpt":"","text":"spring:耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。 工厂模式:在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 解决程序耦合的思路 当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下： Class.forName(\"com.mysql.jdbc.Driver\");//此处只是一个字符串 此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运 行就不要想了，没有驱动不可能运行成功的）。 同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改 源码。 解决这个问题也很简单，使用配置文件配置。 工厂模式解耦 在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的 方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 1、存哪去？ 分析：由于我们是很多对象，肯定要找个集合来存。 这时候有 Map 和 List 供选择。 到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。 所以我们的答案就是 在应用加载时，创建一个 Map，用于存放三层对象。 我们把这个 map 称之为容器。 2、还是没解释什么是工厂？ 工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。 原来： 我们在获取对象时，都是采用 new 的方式。是主动的。 现在: 资源文件: beans.xml xml12345678 bean>beans> 运行Client.xml swift123456789101112131415161718192021222324252627282930313233343536373839package com.ui;import com.service.IAcountService;import com.service.implement.AccountServiceImpl;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;public class Client { public static void main(String[] args) {// IAcountService as = new AccountServiceImpl();// as.saveAccount();// ApplicationContext的三个常用实现类// ClassPathXmlApplicationContext 加载类路径下的配置文件，不在不能加载// FileSystemXmlApplicationContext 加载磁盘任意路径下的配置文件(必须有访问权限)// AnnotationConfigApplicationContext 用于读取注解创建容器// 两个接口引发的问题// ApplicationContext 采用立即加载的方式// 单例对象适用// BeanFactory : 采用延迟加载,id获取对象了，才会真正加载// 多例对象适用// 1.获取核心容器对象// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// ApplicationContext ac = new FileSystemXmlApplicationContext()// 2.根据id获取bean对象// IAcountService as = (IAcountService) ac.getBean(\"acccountService\");// System.out.println(as);// Resource resource = new ClassPathResource(\"bean.xml\");// BeanFactory factory =new XmlBeanFactory(resource); }}","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"jsp入门学习成果","slug":"article3","date":"2020-03-06T08:32:37.000Z","updated":"2020-03-15T11:47:01.685Z","comments":true,"path":"2020/03/06/article3/","link":"","permalink":"http://yoursite.com/2020/03/06/article3/","excerpt":"","text":"要相信，成功并不是成功者的专利，今天的你，不过是少了一点点机会加上毫不动摇的努力。努力让今天过得更有价值，才更有可能实现明天的美好。 接近一个暑假的学习jsp时光带给了我许多。 1.香水商店首先是一个神奇的香水商店，你的香水有毒啊！！！ 2.水果商店然后还有一个水果商店，鬼知道水果商店为什么卖洋葱和西红柿？？？ 3.个人博客第一代然后是上一个版本的个人博客，若大家有兴趣可以再去参观一下 http://47.95.13.8:8080/ceshi/ 呦呦鹿鸣，食野之苹 4.武汉加油想回学校啊，在家是真的无趣，想出门放飞自我，想出去逛吃……武汉加油啊,希望疫情赶紧过去吧。 山河无恙，人间皆安；冬已尽，春可期 http://47.95.13.8:8080/shiyan1_1/ 5.个人商城登陆模块实现完成于前几天。","categories":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/categories/jsp/"}],"tags":[{"name":"jsp开发","slug":"jsp开发","permalink":"http://yoursite.com/tags/jsp%E5%BC%80%E5%8F%91/"}]},{"title":"hexo的主题更换","slug":"article2","date":"2020-03-02T07:42:36.000Z","updated":"2020-03-02T08:08:10.103Z","comments":true,"path":"2020/03/02/article2/","link":"","permalink":"http://yoursite.com/2020/03/02/article2/","excerpt":"","text":"上一篇文章，介绍了如何利用 hexo+github pages 搭建个人博客。那么这篇文章则以我的博客为例详细教你打造个性超赞博客的主题。 现如今用的人最多的是next这个主题，而本人在昨天发现一个神仙主题：Butterfly,It’s so beautiful . 这个主题不过有点废图， 提供2个自己搜图用的网站 https://wallroom.io/ https://www.pexels.com/ 安装在你的博客根目录里 git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 应用主题修改站点配置文件_config.yml，把主题改为Butterfly theme: Butterfly 配置配置文件说明站点配置文件config.yml是hexo工作目录下的主配置文件(还不知道是哪里的，自己google)butterfly.yml是Butterfly的配置文件。它需要你手动将主题目录下的 _config.yml 文件复制到 hexo 工作目录的source/data/butterfly.yml中。如果文件或者文件夹不存在，需要手动创建。*语言修改站点配置文件 _config.yml 默认语言是en 主题支持三种语言 ​ default(en)​ zh-CN (简体中文)​ zh-TW (繁体中文) 导航菜单配置menu: 首页: / || fa fa-home 归档: /archives/ || fa fa-archive 标签: /tags/ || fa fa-tags 分类: /categories/ || fa fa-folder-open 下面是butterfly的官方文档： https://jerryc.me/posts/21cfbf15/#%E5%BF%AB%E9%80%9F%E9%96%8B%E5%A7%8B 然后是本人的博客地址。 https://moyang-mu.github.io/ 总而言之，虽然今天有课，然本人昨天还是战斗到了12点半，从下午三点开始，除了吃饭时间基本都在调bug，今天早上也是调了一上午，真是身心俱疲啊。 还想说一句，就是我昨天因为默认开启了图片懒加载，但又没配置好，结果导致图片只有data-src属性，没有src属性，结果就是自然不能显示了。哎，想想都是泪，昨天晚上基本都是在看代码和博客还有官方文档中度过。","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"jsp的基本内置对象及作用","slug":"jsp1-1","date":"2020-03-02T07:22:45.000Z","updated":"2020-03-15T11:48:46.762Z","comments":true,"path":"2020/03/02/jsp1-1/","link":"","permalink":"http://yoursite.com/2020/03/02/jsp1-1/","excerpt":"","text":"jsp的九大内置对象 bash1234jsp就本质相当于一个servlet，jsp的发明是为了简化我们对servlet的编写，用于在service方法中直接输出， 其中编写的java代码将会在添加到service方法中实现， jsp的重定向和请求转发 bash1234重定向是服务器将这个请求返回给浏览器，浏览器进行重新请求，区别在于，这次的请求的地址使用你上一次传回给他的。请求转发则是这个请求的内容等都不变，只不过把这个请求拿到另一个页面进行处理，处理完的结果在原页面显示。绝对路径:相对于项目的根路径，在路径前+上/相对路径:使用./或者什么都不加 由于cokkie部分版本不识别中文，导致可能出现中文乱码 bash1解决方案:使用两个工具类进行转码，URLEncoder在存储数据时候转码，URLDecoder在取出数据时进行转码。 Request在服务器请求资源原理解析 bash12 Requset在service中使用map集合一次性取出提交的表单数据的方法","categories":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/categories/jsp/"}],"tags":[{"name":"jsp开发","slug":"jsp开发","permalink":"http://yoursite.com/tags/jsp%E5%BC%80%E5%8F%91/"}]},{"title":"hexo的搭建","slug":"article","date":"2017-05-26T04:12:57.000Z","updated":"2020-03-02T07:47:47.725Z","comments":true,"path":"2017/05/26/article/","link":"","permalink":"http://yoursite.com/2017/05/26/article/","excerpt":"","text":"本文使用的是在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。 第一部分 hexo的初级搭建还有部署到github page上，以及个人域名的绑定。(因为囊中羞涩，暂时未购买域名，嘿嘿) Hexo搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub 将hexo部署到GitHub 设置个人域名 发布文章 1.安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。Git教程 windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码sudo apt-get install git 2.安装nodejs Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。 windows：nodejs选择LTS版本就行了 安装完成后，检查一下 node -v npm -v 3. 安装hexo 前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 npm install -g hexo-cli 依旧用hexo -v查看一下版本 至此就全部安装完了。 接下来初始化一下hexo hexo init myblog 这个myblog可以自己取什么名字都行，然后 cd myblog //进入这个myblog文件夹 npm install 新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章和一些其他图片资源等 themes：主题 ** _config.yml: 博客的配置文件** hexo g hexo server 使用ctrl+c可以把服务关掉。 4. GitHub创建个人仓库首先，你先要有一个GitHub账户，去注册一个吧。 注册完登录后，在GitHub.com中看到一个New repository，新建仓库 创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。 点击create repository。 5. 生成SSH添加到GitHubgit config --global user.name \"yourname\" git config --global user.email \"youremail\" 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 可以用以下两条，检查一下你有没有输对 git config user.name git config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C \"youremail\" 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。 ssh -T git@github.com 6. 将hexo部署到GitHub 这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 npm install hexo-deployer-git --save hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西，将之前生成的静态页面等删除（与public文件有关）hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署到github上，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！ 7. 设置个人域名现在你的个人网站的地址是 yourname.github.io，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。 转载： https://blog.csdn.net/sinat_37781304/article/details/82729029","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}