{"meta":{"title":"XIAOHU blog","subtitle":"Welcome to my blog","description":"愿你走出半生路 归来仍是少年","author":"XIAOHU","url":"http://yoursite.com","root":"/"},"pages":[{"title":"文章分类","date":"2017-05-27T05:47:40.000Z","updated":"2020-03-02T08:14:54.853Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2017-05-27T05:47:40.000Z","updated":"2020-03-02T07:19:57.631Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java进阶知识","slug":"java1","date":"2020-03-29T13:55:36.000Z","updated":"2020-03-29T15:55:01.232Z","comments":true,"path":"2020/03/29/java1/","link":"","permalink":"http://yoursite.com/2020/03/29/java1/","excerpt":"","text":"由于感觉到自身java基础的不足，所以打算完善下基础。 1.Java虚拟机——JVMJVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系 统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM 运行在操作系统上。 JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。 JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 2.Object类java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： java123public class MyClass /*extends Object*/ { // ...} 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个： public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 2.2 toString方法方法摘要 public String toString()：返回该对象的字符串表示。 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： java1234567891011public class Person { private String name; private int age; @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } // 省略构造器与Getter Setter} 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 2.3 equals方法方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： java1234567891011121314151617181920import java.util.Objects;public class Person { private String name; private int age; @Override public boolean equals(Object o) { // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age && Objects.equals(name, person.name); }} 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。 3.StringBuilder类3.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： java1234567public class StringDemo { public static void main(String[] args) { String s = \"Hello\"; s += \"World\"; System.out.println(s); }} 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即\"Hello\"、\"World\"和\"HelloWorld\"。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWord 。 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 3.2 StringBuilder概述查阅java.lang.StringBuilder的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 3.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 java123456789public class StringBuilderDemo { public static void main(String[] args) { StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(\"itcast\"); System.out.println(sb2); // itcast }} 3.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： java12345678910111213141516171819202122public class Demo02StringBuilder { public static void main(String[] args) { //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append(\"hello\"); //对比一下 System.out.println(\"builder:\"+builder); System.out.println(\"builder2:\"+builder2); System.out.println(builder == builder2); //true // 可以添加 任何类型 builder.append(\"hello\"); builder.append(\"world\"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append(\"hello\").append(\"world\").append(true).append(100); System.out.println(\"builder:\"+builder); }} 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： java123456789public class Demo16StringBuilder { public static void main(String[] args) { // 链式创建 StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava }}","categories":[{"name":"java语法","slug":"java语法","permalink":"http://yoursite.com/categories/java%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"java基础和进阶","slug":"java基础和进阶","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E5%92%8C%E8%BF%9B%E9%98%B6/"}]},{"title":"异常和线程基础","slug":"threading","date":"2020-03-22T11:00:04.000Z","updated":"2020-03-22T12:57:52.960Z","comments":true,"path":"2020/03/22/threading/","link":"","permalink":"http://yoursite.com/2020/03/22/threading/","excerpt":"","text":"【异常、线程】这几天由于在做项目的时候需要了解线程的调度，虽然对线程以前有所接触，但是从未系统学习过。这几天对线程进行了完善的学习，顺带对异常的处理也相应进行了系统性的了解。 第一章 异常1.1 异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 1.2 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 1.3 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) 1.4 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。 工具类 java1234567public class ArrayTools { // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) { int element = arr[index]; return element; }} 测试类 java12345678public class ExceptionDemo { public static void main(String[] args) { int[] arr = { 34, 12, 67 }; intnum = ArrayTools.getElement(arr, 4) System.out.println(\"num=\" + num); System.out.println(\"over\"); }} 上述程序执行过程图解： 第二章 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 2.1 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： haxe1throw new 异常类名(参数); 例如： java123throw new NullPointerException(\"要访问的arr数组不存在\");throw new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 java123456789101112131415161718192021222324252627public class ThrowDemo { public static void main(String[] args) { //创建一个数组 int[] arr = {2,4,52,2}; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(\"over\"); } /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index){ //判断 索引是否越界 if(indexarr.length-1){ /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了~~~\"); } int element = arr[index]; return element; }} 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 2.2 Objects非空判断还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： java12345public static T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj;} 2.3 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： angelscript1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{ } 声明异常的代码演示： java12345678910111213public class ThrowsDemo { public static void main(String[] args) throws FileNotFoundException { read(\"a.txt\"); } // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException { if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 // 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); } }} throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 java123456789101112131415public class ThrowsDemo2 { public static void main(String[] args) throws IOException { read(\"a.txt\"); } public static void read(String path)throws FileNotFoundException, IOException { if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 // 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); } if (!path.equals(\"b.txt\")) { throw new IOException(); } }} 2.4 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： java123456try{ 编写可能会出现异常的代码}catch(异常类型 e){ 处理异常的代码 //记录日志/打印异常信息/继续抛出异常} try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： java123456789101112131415161718192021public class TryCatchDemo { public static void main(String[] args) { try {// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(\"b.txt\"); } catch (FileNotFoundException e) {// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); } System.out.println(\"over\"); } /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException { if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); } }} 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 2.4 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： java1234567891011121314151617181920212223public class TryCatchDemo4 { public static void main(String[] args) { try { read(\"a.txt\"); } catch (FileNotFoundException e) { //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); } finally { System.out.println(\"不管程序怎样，这里都将会被执行。\"); } System.out.println(\"over\"); } /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException { if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); } }} 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 2.5 异常注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： java123456789try{ 编写可能会出现异常的代码}catch(异常类型A e){ 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常}catch(异常类型B e){ 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常} 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 第三章 自定义异常3.1 概述为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 3.2 自定义异常的练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： java12345678910111213141516// 业务逻辑异常public class RegisterException extends Exception { /** * 空参构造 */ public RegisterException() { } /** * * @param message 表示异常提示 */ public RegisterException(String message) { super(message); }} 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 java123456789101112131415161718192021222324252627public class Demo { // 模拟数据库中已存在账号 private static String[] names = {\"bill\",\"hill\",\"jill\"}; public static void main(String[] args) { //调用方法 try{ // 可能出现异常的代码 checkUsername(\"nill\"); System.out.println(\"注册成功\");//如果没有异常就是注册成功 }catch(RegisterException e){ //处理异常 e.printStackTrace(); } } //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException{ for (String name : names) { if(name.equals(uname)){//如果名字在这里面 就抛出登陆异常 throw new RegisterException(\"亲\"+name+\"已经被注册了！\"); } } return true; }} 第四章 多线程我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述问题,咱们得使用多进程或者多线程来解决. 4.1 并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 4.2 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 我们可以再电脑底部任务栏，右键—–>打开任务管理器,可以查看当前任务的进程： 进程 线程 线程调度: 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 4.3 创建线程类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码如下： 测试类： java123456789101112public class Demo01 { public static void main(String[] args) { //创建自定义线程对象 MyThread mt = new MyThread(\"新的线程！\"); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i < 10; i++) { System.out.println(\"main线程！\"+i); } }} 自定义线程类： java12345678910111213141516public class MyThread extends Thread { //定义指定线程名称的构造方法 public MyThread(String name) { //调用父类的String参数的构造方法，指定线程的名称 super(name); } /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() { for (int i = 0; i < 10; i++) { System.out.println(getName()+\"：正在执行！\"+i); } }}","categories":[{"name":"java语法","slug":"java语法","permalink":"http://yoursite.com/categories/java%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"异常","slug":"异常","permalink":"http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"那些年我踩过的坑","slug":"cai","date":"2020-03-16T07:04:05.000Z","updated":"2020-03-16T07:25:57.015Z","comments":true,"path":"2020/03/16/cai/","link":"","permalink":"http://yoursite.com/2020/03/16/cai/","excerpt":"","text":"最近这两天，由于切实的感觉到gitalk评论系统实在是太慢了，就想换一个。 由于 来必力（LiveRe） Disqus 和gitalk一个德性 加载速度贼慢，甚至有被墙的可能，寻觅了很久之后， 选择了valine系统。 然后，经过一番常规操作之后，在加载上valine之后，疯狂报错。 如下图 此处的我默默的流下伤心的泪水。 然而经过我翻墙后在谷歌坚持不懈地寻找，最后终于找到了解决方法。 右键检查发现 这该死的，居然把注释也给获取了。找到主题下的_config.yml，删掉注释重新部署就可以完成了 。 如果还没解决的话可以试试切换leancloud节点，我这里是华北节点，创建class 。","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"http://yoursite.com/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"spring之数据库增删改查","slug":"article8","date":"2020-03-15T13:05:55.000Z","updated":"2020-03-15T13:36:05.630Z","comments":true,"path":"2020/03/15/article8/","link":"","permalink":"http://yoursite.com/2020/03/15/article8/","excerpt":"","text":"基于junit和mysql的spring开发1.持久层实现类java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.dao.impl;import com.dao.IAccountDao;import com.domain.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.SQLException;import java.util.List;//账户持久层实现类public class AccountDaoImpl implements IAccountDao { private QueryRunner runner; public void setRunner(QueryRunner runner) { this.runner = runner; } public List findAllAccount() { try { return runner.query(\"select * from account\",new BeanListHandler(Account.class)); } catch (SQLException e) { throw new RuntimeException(e); } } public Account findAccountById(Integer accountId) { try { return runner.query(\"select * from account where id = ? \",new BeanHandler(Account.class),accountId); } catch (SQLException e) { throw new RuntimeException(e); } } public void saveAccount(Account account) { try { runner.update(\"insert into account(name,money) values(?,?)\",account.getName(),account.getMoney()); } catch (SQLException e) { throw new RuntimeException(e); } } public void updateAccount(Account account) { try { runner.update(\"update account set name=?,money=? where id=?\",account.getName(),account.getMoney(),account.getId()); }catch (SQLException e) { throw new RuntimeException(e); } } public void deleteAccount(Integer accountId) { try { runner.update(\"delete from account where id = ?\",accountId); }catch (SQLException e) { throw new RuntimeException(e); } }} 2.账户类pgsql123456789101112131415161718192021222324252627282930313233343536373839404142package com.domain;import java.io.Serializable;public class Account implements Serializable { private Integer id; private String name; private Float money; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Float getMoney() { return money; } public void setMoney(Float money) { this.money = money; } @Override public String toString() { return \"Account{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", money=\" + money + '}'; }} 3.业务层实现类aspectj1234567891011121314151617181920212223242526272829303132333435363738package com.service.impl;import com.dao.IAccountDao;import com.domain.Account;import com.service.IAccountService;import java.util.List;//账户业务层实现类public class AccountServiceImpl implements IAccountService { private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) { this.accountDao = accountDao; } public List findAllAccount() { return accountDao.findAllAccount(); } public Account findAccountById(Integer accountId) { return accountDao.findAccountById(accountId); } public void saveAccount(Account account) { accountDao.saveAccount(account); } public void updateAccount(Account account) { accountDao.updateAccount(account); } public void deleteAccount(Integer accountId) { accountDao.deleteAccount(accountId); }} 4.bean.xml创建bean和数据库驱动 applescript1234567891011121314151617181920212223242526version=\"1.0\" encoding=\"UTF-8\"?>\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> property> property> -- 配置QueryRunner--> -- 注入数据源--> -- 配置数据源--> property> property> property> property> 4.junit实现的测试类reasonml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.test;import com.domain.Account;import com.service.IAccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;//使用junit单元测试public class AccountServioceTest { @Test public void testFindAll() {// 1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 List accountcs = as.findAllAccount(); for (Account account : accountcs){ System.out.println(account); } } @Test public void testFindOne() { // 1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 Account account =as.findAccountById(1); System.out.println(account); } @Test public void testSave() { Account account =new Account(); account.setName(\"test\"); account.setMoney(12345f); ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 as.saveAccount(account);// System.out.println(account); } @Test public void testUpdate() { ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 Account account = as.findAccountById(4); account.setMoney(23456f); as.updateAccount(account); } @Test public void testDelete() { ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 as.deleteAccount(4); }} 5.设置导入包的坐标–pom.xmlxml12345678910111213141516171819202122232425262728293031323334353637383940 4.0.0modelVersion> org.examplegroupId> springday02_02artifactId> 1.0-SNAPSHOTversion> jarpackaging> org.springframeworkgroupId> spring-contextartifactId> 5.0.2.RELEASEversion> dependency> commons-dbutilsgroupId> commons-dbutilsartifactId> 1.4version> dependency> mysqlgroupId> mysql-connector-javaartifactId> 8.0.19version> dependency> c3p0groupId> c3p0artifactId> 0.9.1.2version> dependency> junitgroupId> junitartifactId> 4.10version> dependency> dependencies>project>","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"三层架构","slug":"三层架构","permalink":"http://yoursite.com/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"}]},{"title":"spring之注解配置","slug":"article7","date":"2020-03-15T11:50:50.000Z","updated":"2020-03-15T13:02:37.804Z","comments":true,"path":"2020/03/15/article7/","link":"","permalink":"http://yoursite.com/2020/03/15/article7/","excerpt":"","text":"1.基于注解配置的bean.xml的约束条件xml1234567891011121314 依赖中需要aop的jar包 告知spring在创建容器需要的包，配置标签在context的名称空间和约束中 context:component-scan>beans> 2.注解配置创建Bean加入Ioc容器*曾经XML的配置：monkey12345* \"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"* scope=\"\" init-method=\"\" destroy-method=\"\">* property>* *使用注解配置1.用于创建对象的stata123456789101112131415161718192021222324252627282930 * 他们的作用就和在XML配置文件中编写一个标签实现的功能是一样的 * Component: * 作用：用于把当前类对象存入spring容器中 * 属性： * value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。 * Controller：一般用在表现层 * Service：一般用在业务层 * Repository：一般用在持久层 * 以上三个注解他们的作用和属性与Component是一模一样。 * 他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰 *package com.itheima.dao.impl;import com.itheima.dao.IAccountDao;import org.springframework.stereotype.Repository;/** * 账户的持久层实现类 */@Repository(\"accountDao1\")public class AccountDaoImpl implements IAccountDao { public void saveAccount(){ System.out.println(\"保存了账户1111111111111\"); }} 2.用于注入数据的gams1234567891011121314151617181920212223242526* 他们的作用就和在xml配置文件中的bean标签中写一个标签的作用是一样的* Autowired:* 作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功* 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。* 如果Ioc容器中有多个类型匹配时：* 出现位置：* 可以是变量上，也可以是方法上* 细节：* 在使用注解注入时，set方法就不是必须的了。* Qualifier:* 作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以* 属性：* value：用于指定注入bean的id。* Resource* 作用：直接按照bean的id注入。它可以独立使用* 属性：* name：用于指定bean的id。* 以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。* 另外，集合类型的注入只能通过XML来实现。** Value* 作用：用于注入基本类型和String类型的数据* 属性：* value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式）* SpEL的写法：${表达式}* 3.用于改变作用范围的asciidoc123456789101112* 他们的作用就和在bean标签中使用scope属性实现的功能是一样的* Scope* 作用：用于指定bean的作用范围* 属性：* value：指定范围的取值。常用取值：singleton prototype** 和生命周期相关 了解* 他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的* PreDestroy* 作用：用于指定销毁方法* PostConstruct* 作用：用于指定初始化方法 3.业务层代码实现crystal12345678910111213141516171819202122232425262728293031323334353637package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.service.IAccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;import javax.annotation.Resource;@Component//@Service(\"accountService\")//@Scope(\"prototype\")public class AccountServiceImpl implements IAccountService {// @Autowired// @Qualifier(\"accountDao1\") @Resource(name = \"accountDao2\") private IAccountDao accountDao = null; @PostConstruct public void init(){ System.out.println(\"初始化方法执行了\"); } @PreDestroy public void destroy(){ System.out.println(\"销毁方法执行了\"); } public void saveAccount(){ accountDao.saveAccount(); }} 4.创建容器调用业务层pgsql1234567891011121314151617181920212223242526272829package com.itheima.ui;import com.itheima.dao.IAccountDao;import com.itheima.service.IAccountService;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 模拟一个表现层，用于调用业务层 */public class Client { /** * @param args */ public static void main(String[] args) { //1.获取核心容器对象// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取Bean对象 IAccountService as = (IAccountService)ac.getBean(\"accountServiceImpl\");// IAccountService as2 = (IAccountService)ac.getBean(\"accountService\"); System.out.println(as);// IAccountDao adao = ac.getBean(\"accountDao\",IAccountDao.class);// System.out.println(adao);// System.out.println(as == as2); as.saveAccount(); ac.close(); }}","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"JDBC入门","slug":"article6","date":"2020-03-13T05:33:07.000Z","updated":"2020-03-13T06:49:49.974Z","comments":true,"path":"2020/03/13/article6/","link":"","permalink":"http://yoursite.com/2020/03/13/article6/","excerpt":"","text":"1. JDBC基本概念 2. JDBC基本使用 3. 对JDBC中各个接口和类详解JDBC：1. 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 2. 快速入门： * 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql 5. 获取执行sql语句的对象 Statement 6. 执行sql，接受返回结果 7. 处理结果 8. 释放资源 * 代码实现： //1. 导入驱动jar包 //2.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/shopping?useUnicode=true&characterEncoding=utf8\",\"root\",\"****\"); //4.定义sql语句 String sql = \"update account set balance = 500 where id = 1\"; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); 3. 详解各个对象： 1. DriverManager：驱动管理对象 * 功能： 1. 注册驱动：告诉程序该使用哪一个数据库驱动jar static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(\"com.mysql.jdbc.Driver\"); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(\"Can't register driver!\"); } } 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2. 获取数据库连接： * 方法：static Connection getConnection(String url, String user, String password) * 参数： * url：指定连接的路径 * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称?useUnicode=true&characterEncoding=utf8 * 例子：jdbc:mysql://localhost:3306/shopping?useUnicode=true&characterEncoding=utf8 * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 * user：用户名 * password：密码 2. Connection：数据库连接对象 1. 功能： 1. 获取执行sql 的对象 * Statement createStatement() * PreparedStatement prepareStatement(String sql) 2. 管理事务： * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 提交事务：commit() * 回滚事务：rollback() 3. Statement：执行sql的对象 1. 执行sql 1. boolean execute(String sql) ：可以执行任意的sql 了解 2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值>0的则执行成功，反之，则失败。 3. ResultSet executeQuery(String sql) ：执行DQL（select)语句 2. 练习： package cn; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Statement; public class jdbc2 { public static void main(String[] args) { Statement stmt = null; Connection conn =null; // 1.注册驱动 try { Class.forName(\"com.mysql.jdbc.Driver\"); // 2.定义sql // INSERT INTO `items` VALUES ('1', '沃特篮球鞋', '佛山', '180', '500', '001.jpg'); String sql = \"INSERT INTO `items` VALUES ('11', '篮球鞋', '佛山', '180', '500', '011.jpg')\"; // 获取connection对象 conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/shopping?useUnicode=true&characterEncoding=utf8\",\"root\",\"123456\"); // 4.获取执行sql对象 stmt = conn.createStatement(); // 5.执行sql int count = stmt.executeUpdate(sql); System.out.println(count); if (count>0) System.out.println(\"添加成功\"); } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { // 避免空指针异常 if (stmt!=null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } 4. ResultSet：结果集对象,封装查询结果 * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true * getXxx(参数):获取数据 * Xxx：代表数据类型 如： int getInt() , String getString() * 参数： 1. int：代表列的编号,从1开始 如： getString(1) 2. String：代表列名称。 如： getDouble(\"balance\") * 注意： * 使用步骤： 1. 游标向下移动一行 2. 判断是否有数据 3. 获取数据 //循环判断游标是否是最后一行末尾。 while(rs.next()){ //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(\"name\"); double balance = rs.getDouble(3); System.out.println(id + \"---\" + name + \"---\" + balance); } 5. PreparedStatement：执行sql的对象(使用较多) 1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 1. 输入用户随便，输入密码：a' or 'a' = 'a 2. sql：select * from user where username = 'fhdsjkf' and password = 'a' or 'a' = 'a' 2. 解决sql注入问题：使用PreparedStatement对象来解决 3. 预编译的SQL：参数使用?作为占位符 4. 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 5. 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 6. 给？赋值： * 方法： setXxx(参数1,参数2) * 参数1：？的位置编号 从1 开始 * 参数2：？的值 7. 执行sql，接受返回结果，不需要传递sql语句 8. 处理结果 9. 释放资源 案例代码: /** * 练习：jdbc+jdbcutils+mysql * * 需求： * 1. 通过键盘录入用户名和密码 * 2. 判断用户是否登录成功 */ package cn.itcast.jdbc; import cn.itcast.util.JDBCUtils; import java.sql.*; import java.util.Scanner; public class JDBCDemo9 { public static void main(String[] args) { //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(\"请输入用户名：\"); String username = sc.nextLine(); System.out.println(\"请输入密码：\"); String password = sc.nextLine(); //2.调用方法 boolean flag = new JDBCDemo9().login2(username, password); //3.判断结果，输出不同语句 if(flag){ //登录成功 System.out.println(\"登录成功！\"); }else{ System.out.println(\"用户名或密码错误！\"); } } /** * 登录方法 */ public boolean login(String username ,String password){ if(username == null || password == null){ return false; } //连接数据库判断是否登录成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; //1.获取连接 try { conn = JDBCUtils.getConnection(); //2.定义sql String sql = \"select * from user where username = '\"+username+\"' and password = '\"+password+\"' \"; System.out.println(sql); //3.获取执行sql的对象 stmt = conn.createStatement(); //4.执行查询 rs = stmt.executeQuery(sql); //5.判断 /* if(rs.next()){//如果有下一行，则返回true return true; }else{ return false; }*/ return rs.next();//如果有下一行，则返回true } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,stmt,conn); } return false; }​ /** * 登录方法,使用PreparedStatement实现 */ public boolean login2(String username ,String password){ if(username == null || password == null){ return false; } //连接数据库判断是否登录成功 Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; //1.获取连接 try { conn = JDBCUtils.getConnection(); //2.定义sql String sql = \"select * from user where username = ? and password = ?\"; //3.获取执行sql的对象 pstmt = conn.prepareStatement(sql); //给?赋值 pstmt.setString(1,username); pstmt.setString(2,password); //4.执行查询,不需要传递sql rs = pstmt.executeQuery(); //5.判断 /* if(rs.next()){//如果有下一行，则返回true return true; }else{ return false; }*/ return rs.next();//如果有下一行，则返回true } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,pstmt,conn); } return false; } } ​​ 5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作​ 1. 可以防止SQL注入​ 2. 效率更高 抽取JDBC工具类 ： JDBCUtils* 目的：简化书写 * 分析： 1. 抽取注册驱动 2. 抽取一个方法获取连接对象 * 需求：不想传递参数（麻烦），还得保证工具类的通用性。 * 解决：配置文件 jdbc.properties url= user= password= 3. 抽取一个方法释放资源 package utils; import java.io.FileReader; import java.io.IOException; import java.net.URL; import java.sql.*; import java.util.Properties; public class jdbcutils { private static String url; private static String user; private static String password; private static String driver; static { // 读取资源文件获取值 // 1.Properties try { Properties pro =new Properties(); // 获取src路径下的方式 // ClassLoader classLoader = jdbcutils.class.getClassLoader(); // URL res = classLoader.getResource(\"jdbc.properties\"); // String path =res.getPath(); // System.out.println(path); // 2.加载文件 pro.load(new FileReader(\"src/jdbc.properties\")); // pro.load(new FileReader(path)); url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver =pro.getProperty(\"driver\"); Class.forName(driver); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } }​ ​ // 获取连接，返回连接对象 public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url,user,password); } // 释放资源 public static void close(Statement stmt,Connection conn){ if (stmt!=null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } public static void close(Statement stmt,Connection conn,ResultSet rs){ if (rs!=null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (stmt!=null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } }​ ​","categories":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/categories/jsp/"}],"tags":[{"name":"java工具类","slug":"java工具类","permalink":"http://yoursite.com/tags/java%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"title":"spring之依赖注入数据","slug":"article5","date":"2020-03-10T10:24:07.000Z","updated":"2020-03-15T11:48:14.619Z","comments":true,"path":"2020/03/10/article5/","link":"","permalink":"http://yoursite.com/2020/03/10/article5/","excerpt":"","text":"原本很认真的写，然而天有不测风云，更新个编辑器版本，我原本写的全没了，算了算了。 1.放在resource下的bean.xmlxquery123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154\"1.0\" encoding=\"UTF-8\"?>\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> 依赖注入: dependency injection Ioc的作用 降低程序的依赖 依赖关系的管理交给spring维护 在当前类需要用到其他类的对象，由spring提供，需要再配置文件说明 依赖注入: 能注入的数据，三类： 基本类型和string 其他bean类型（在配置文件或者注解配置过的bean） 复杂类型/集合类型 注入方式: 1.使用构造函数 2.使用set 3.使用注解提供 构造函数注入 使用constructor-arg type：用于注入的数据的数据类型 index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引的位置从0开始 name：用于指定给构造函数中制定名称的参数赋值 value：提供基本类型和string类型的数据 ref：用于指定其他的bean类型数据。 优势： 获取bean对象时，注入数据是必须的操作 弊端： 如果用不到这些数据，也必须提供。 constructor-arg> constructor-arg> constructor-arg> bean> bean> --set方法注入 name：用于指定注入时调用的set方法名称 value：提供基本类型和string类型的数据 ref：用于指定其他的bean类型数据。 优势： 创建对象没有明确的限制，可以直接用默认构造函数 弊端： 如果某个成员必须有值，则获取对象时set方法没有执行 property> property> property> bean> 集合类型注入 用于给list结构注入的标签由 list array set 用于给map结构集合注入 map props 结构相同，标签可以互换 AAAAAAvalue> bbbbvalue> ccccvalue> array> property> AAAAAAvalue> bbbbvalue> ccccvalue> list> property> AAAAAAvalue> bbbbvalue> ccccvalue> set> property> entry> entry> map> property> ccccprop> props> property> bean> --把对象的创建交给spring来管理-- --spring对bian的管理细节 1.创建bean的三种方式 2.bean的作用范围 3.bean的生命周期 --1.使用默认构造函数 使用bean标签，配以id和class属性之后，没有其他属性和标签时，采用的就是默认构造函数， 如果类中没有默认构造函数，则对象无法创建 bean>--> --2.使用工厂中的方法创建对象，或者使用某个类中的方法创建对象，并存入spring容器 bean> bean> --使用工厂中的静态方法创建对象 bean> bean的作用范围调整 bean标签的scope属性: 取值: singleton 单例(默认值) prototype 多例的 request 作用于web应用的请求范围 session 作用于web应用的会话范围 global-session 集群环境的会话范围(全局会话范围),当不是集群环境时，就是session --bean对象的生命周期 单例对象 生命周期和容器相同 多例对象 使用对象时候创建，只要是在使用过程中就一直活着， java垃圾回收器来进行回收 2.Client.javapgsql123456789101112131415161718192021222324252627282930313233343536package com.itheima.ui;//import com.itheima.dao.IAccountDao;import com.itheima.service.IAccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 模拟一个表现层，用于调用业务层 */public class Client { public static void main(String[] args) { //1.获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// ApplicationContext ac = new FileSystemXmlApplicationContext(\"C:\\\\Users\\\\zhy\\\\Desktop\\\\bean.xml\"); //2.根据id获取Bean对象// IAccountDao adao = ac.getBean(\"accountDao\",IAccountDao.class);// IAccountService as = (IAccountService)ac.getBean(\"accountService\");// as.saveAccount();// IAccountService as = (IAccountService)ac.getBean(\"accountService2\");// as.saveAccount(); IAccountService as = (IAccountService)ac.getBean(\"accountService3\"); as.saveAccount(); //--------BeanFactory----------// Resource resource = new ClassPathResource(\"bean.xml\");// BeanFactory factory = new XmlBeanFactory(resource);// IAccountService as = (IAccountService)factory.getBean(\"accountService\");// System.out.println(as); }}","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"浅谈http协议","slug":"article4","date":"2020-03-09T01:52:56.000Z","updated":"2020-03-15T11:47:20.236Z","comments":true,"path":"2020/03/09/article4/","link":"","permalink":"http://yoursite.com/2020/03/09/article4/","excerpt":"","text":"HTTP 超文本传输协议 Hyper Text Transfer Protocol 当我们在浏览器的地址栏输入一个地址的时候，就能够访问服务器的某个页面 这个过程本身就是两个应用程序之间的交互，一个应用程序是浏览器，另一个应用程序是服务器。 协议是什么？ 协议就是不同的应用程序之间按照事先做好的约定进行的通信。 这样就能互相读懂对方的意思。 浏览器和WEB服务器之间，使用的就是一种叫做HTTP的协议。 这样是BS (Browser Server )架构模型的基础 请求消息请求消息 由 请求行，请求头部，空行和请求数据4部分组成 1.请求行格式：请求方式 资源路径 HTTP版本号举例：GET/test.html HTTP/1.1请求方式：POST,HEAD,OPTIONS,DELETE,TRACE,PUT 2.请求头 请求头部信息提供了如下信息:Host: 主机名User-Agent: 浏览器基本资料Accept: 浏览器能够识别的响应类型Accept-Language: 浏览器默认语言Accept-Encoding: 浏览器能够识别的压缩方式Referer: 来路页面， /addHero 这个路径是通过addHero.html这个页面跳转过来的。Connecton：是否保持连接 3.请求数据​ post方法中，会把数据以key value形式发送请求 4.空行​ 发送回车符和换行符，通知服务器以下不再有请求头 响应消息响应信息由状态行，响应头，响应正文组成 1.状态行格式如下： HTTP-Version Status-Code Reason-Phrase CRLF 其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。 HTTP状态码当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。HTTP状态码的英文为HTTP Status Code。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 2.HTTP响应头响应头的方法 3.响应正文如图所示，在响应正文里就会是具体的html内容了。当然访问不同的页面，就不一定是html，有可能是css, js,甚至图片了。","categories":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/categories/jsp/"}],"tags":[{"name":"jsp开发","slug":"jsp开发","permalink":"http://yoursite.com/tags/jsp%E5%BC%80%E5%8F%91/"}]},{"title":"spring之获取容器","slug":"spring1","date":"2020-03-08T12:04:26.000Z","updated":"2020-03-15T11:49:50.317Z","comments":true,"path":"2020/03/08/spring1/","link":"","permalink":"http://yoursite.com/2020/03/08/spring1/","excerpt":"","text":"spring:耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。 工厂模式:在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 解决程序耦合的思路 当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下： Class.forName(\"com.mysql.jdbc.Driver\");//此处只是一个字符串 此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运 行就不要想了，没有驱动不可能运行成功的）。 同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改 源码。 解决这个问题也很简单，使用配置文件配置。 工厂模式解耦 在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的 方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 1、存哪去？ 分析：由于我们是很多对象，肯定要找个集合来存。 这时候有 Map 和 List 供选择。 到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。 所以我们的答案就是 在应用加载时，创建一个 Map，用于存放三层对象。 我们把这个 map 称之为容器。 2、还是没解释什么是工厂？ 工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。 原来： 我们在获取对象时，都是采用 new 的方式。是主动的。 现在: 资源文件: beans.xml xml12345678 bean>beans> 运行Client.xml swift123456789101112131415161718192021222324252627282930313233343536373839package com.ui;import com.service.IAcountService;import com.service.implement.AccountServiceImpl;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;public class Client { public static void main(String[] args) {// IAcountService as = new AccountServiceImpl();// as.saveAccount();// ApplicationContext的三个常用实现类// ClassPathXmlApplicationContext 加载类路径下的配置文件，不在不能加载// FileSystemXmlApplicationContext 加载磁盘任意路径下的配置文件(必须有访问权限)// AnnotationConfigApplicationContext 用于读取注解创建容器// 两个接口引发的问题// ApplicationContext 采用立即加载的方式// 单例对象适用// BeanFactory : 采用延迟加载,id获取对象了，才会真正加载// 多例对象适用// 1.获取核心容器对象// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// ApplicationContext ac = new FileSystemXmlApplicationContext()// 2.根据id获取bean对象// IAcountService as = (IAcountService) ac.getBean(\"acccountService\");// System.out.println(as);// Resource resource = new ClassPathResource(\"bean.xml\");// BeanFactory factory =new XmlBeanFactory(resource); }}","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"jsp入门学习成果","slug":"article3","date":"2020-03-06T08:32:37.000Z","updated":"2020-03-15T11:47:01.685Z","comments":true,"path":"2020/03/06/article3/","link":"","permalink":"http://yoursite.com/2020/03/06/article3/","excerpt":"","text":"要相信，成功并不是成功者的专利，今天的你，不过是少了一点点机会加上毫不动摇的努力。努力让今天过得更有价值，才更有可能实现明天的美好。 接近一个暑假的学习jsp时光带给了我许多。 1.香水商店首先是一个神奇的香水商店，你的香水有毒啊！！！ 2.水果商店然后还有一个水果商店，鬼知道水果商店为什么卖洋葱和西红柿？？？ 3.个人博客第一代然后是上一个版本的个人博客，若大家有兴趣可以再去参观一下 http://47.95.13.8:8080/ceshi/ 呦呦鹿鸣，食野之苹 4.武汉加油想回学校啊，在家是真的无趣，想出门放飞自我，想出去逛吃……武汉加油啊,希望疫情赶紧过去吧。 山河无恙，人间皆安；冬已尽，春可期 http://47.95.13.8:8080/shiyan1_1/ 5.个人商城登陆模块实现完成于前几天。","categories":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/categories/jsp/"}],"tags":[{"name":"jsp开发","slug":"jsp开发","permalink":"http://yoursite.com/tags/jsp%E5%BC%80%E5%8F%91/"}]},{"title":"hexo的主题更换","slug":"article2","date":"2020-03-02T07:42:36.000Z","updated":"2020-03-02T08:08:10.103Z","comments":true,"path":"2020/03/02/article2/","link":"","permalink":"http://yoursite.com/2020/03/02/article2/","excerpt":"","text":"上一篇文章，介绍了如何利用 hexo+github pages 搭建个人博客。那么这篇文章则以我的博客为例详细教你打造个性超赞博客的主题。 现如今用的人最多的是next这个主题，而本人在昨天发现一个神仙主题：Butterfly,It’s so beautiful . 这个主题不过有点废图， 提供2个自己搜图用的网站 https://wallroom.io/ https://www.pexels.com/ 安装在你的博客根目录里 git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 应用主题修改站点配置文件_config.yml，把主题改为Butterfly theme: Butterfly 配置配置文件说明站点配置文件config.yml是hexo工作目录下的主配置文件(还不知道是哪里的，自己google)butterfly.yml是Butterfly的配置文件。它需要你手动将主题目录下的 _config.yml 文件复制到 hexo 工作目录的source/data/butterfly.yml中。如果文件或者文件夹不存在，需要手动创建。*语言修改站点配置文件 _config.yml 默认语言是en 主题支持三种语言 ​ default(en)​ zh-CN (简体中文)​ zh-TW (繁体中文) 导航菜单配置menu: 首页: / || fa fa-home 归档: /archives/ || fa fa-archive 标签: /tags/ || fa fa-tags 分类: /categories/ || fa fa-folder-open 下面是butterfly的官方文档： https://jerryc.me/posts/21cfbf15/#%E5%BF%AB%E9%80%9F%E9%96%8B%E5%A7%8B 然后是本人的博客地址。 https://moyang-mu.github.io/ 总而言之，虽然今天有课，然本人昨天还是战斗到了12点半，从下午三点开始，除了吃饭时间基本都在调bug，今天早上也是调了一上午，真是身心俱疲啊。 还想说一句，就是我昨天因为默认开启了图片懒加载，但又没配置好，结果导致图片只有data-src属性，没有src属性，结果就是自然不能显示了。哎，想想都是泪，昨天晚上基本都是在看代码和博客还有官方文档中度过。","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"jsp的基本内置对象及作用","slug":"jsp1-1","date":"2020-03-02T07:22:45.000Z","updated":"2020-03-15T11:48:46.762Z","comments":true,"path":"2020/03/02/jsp1-1/","link":"","permalink":"http://yoursite.com/2020/03/02/jsp1-1/","excerpt":"","text":"jsp的九大内置对象 bash1234jsp就本质相当于一个servlet，jsp的发明是为了简化我们对servlet的编写，用于在service方法中直接输出， 其中编写的java代码将会在添加到service方法中实现， jsp的重定向和请求转发 bash1234重定向是服务器将这个请求返回给浏览器，浏览器进行重新请求，区别在于，这次的请求的地址使用你上一次传回给他的。请求转发则是这个请求的内容等都不变，只不过把这个请求拿到另一个页面进行处理，处理完的结果在原页面显示。绝对路径:相对于项目的根路径，在路径前+上/相对路径:使用./或者什么都不加 由于cokkie部分版本不识别中文，导致可能出现中文乱码 bash1解决方案:使用两个工具类进行转码，URLEncoder在存储数据时候转码，URLDecoder在取出数据时进行转码。 Request在服务器请求资源原理解析 bash12 Requset在service中使用map集合一次性取出提交的表单数据的方法","categories":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/categories/jsp/"}],"tags":[{"name":"jsp开发","slug":"jsp开发","permalink":"http://yoursite.com/tags/jsp%E5%BC%80%E5%8F%91/"}]},{"title":"hexo的搭建","slug":"article","date":"2017-05-26T04:12:57.000Z","updated":"2020-03-02T07:47:47.725Z","comments":true,"path":"2017/05/26/article/","link":"","permalink":"http://yoursite.com/2017/05/26/article/","excerpt":"","text":"本文使用的是在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。 第一部分 hexo的初级搭建还有部署到github page上，以及个人域名的绑定。(因为囊中羞涩，暂时未购买域名，嘿嘿) Hexo搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub 将hexo部署到GitHub 设置个人域名 发布文章 1.安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。Git教程 windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码sudo apt-get install git 2.安装nodejs Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。 windows：nodejs选择LTS版本就行了 安装完成后，检查一下 node -v npm -v 3. 安装hexo 前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 npm install -g hexo-cli 依旧用hexo -v查看一下版本 至此就全部安装完了。 接下来初始化一下hexo hexo init myblog 这个myblog可以自己取什么名字都行，然后 cd myblog //进入这个myblog文件夹 npm install 新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章和一些其他图片资源等 themes：主题 ** _config.yml: 博客的配置文件** hexo g hexo server 使用ctrl+c可以把服务关掉。 4. GitHub创建个人仓库首先，你先要有一个GitHub账户，去注册一个吧。 注册完登录后，在GitHub.com中看到一个New repository，新建仓库 创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。 点击create repository。 5. 生成SSH添加到GitHubgit config --global user.name \"yourname\" git config --global user.email \"youremail\" 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 可以用以下两条，检查一下你有没有输对 git config user.name git config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C \"youremail\" 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。 ssh -T git@github.com 6. 将hexo部署到GitHub 这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 npm install hexo-deployer-git --save hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西，将之前生成的静态页面等删除（与public文件有关）hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署到github上，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！ 7. 设置个人域名现在你的个人网站的地址是 yourname.github.io，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。 转载： https://blog.csdn.net/sinat_37781304/article/details/82729029","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}