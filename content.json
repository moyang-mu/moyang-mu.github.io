{"meta":{"title":"XIAOHU blog","subtitle":"Welcome to my blog","description":"愿你走出半生路 归来仍是少年","author":"XIAOHU","url":"https://www.mo-yang.top","root":"/"},"pages":[{"title":"文章分类","date":"2017-05-27T05:47:40.000Z","updated":"2020-03-02T07:19:57.631Z","comments":true,"path":"tags/index.html","permalink":"https://www.mo-yang.top/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2017-05-27T05:47:40.000Z","updated":"2020-03-02T08:14:54.853Z","comments":true,"path":"categories/index.html","permalink":"https://www.mo-yang.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"个人hexo博客提交百度收录","slug":"tijiao","date":"2020-06-06T01:59:05.000Z","updated":"2020-06-06T03:19:54.965Z","comments":true,"path":"2020/06/06/tijiao/","link":"","permalink":"https://www.mo-yang.top/2020/06/06/tijiao/","excerpt":"","text":"查看网站是否被收录首先我们可以输入 site:域名 来查看域名是否被搜索引擎收录，如下图所示，表示没有收录： 百度资源平台添加网站访问百度搜索资源平台官网，注册或者登陆百度账号，依次选择【用户中心】-【站点管理】，添加你的网站，在添加站点时会让你选择协议头（http 或者 https），如果选择 https，它会验证你的站点，大约能在一天之内完成，我的网站已经实现了全站 https，因此选择了 https 协议。 之后会让你验证网站所有权，提供三种验证方式： 文件验证：下载给定的文件，将其放到本地主题目录 source 文件夹，然后部署上去完成验证 HTML 标签验证：一般是给一个 meta 标签，放到首页 与 标签之间即可完成验证 CNAME 验证：个人觉得这种方法最简单，去域名 DNS 添加一个 CNAME 记录即可完成验证 个人推荐采用第三种方式，第一种和第二张不知道为什么报错301. 由于本人验证已经通过了，下图为网上的图片。 提交百度进行收录在成功通过验证后，要把url提交百度进行收录。百度提供了自动提交和手动提交两种方式，其中自动提交又分为主动推送、自动推送和 sitemap 三种方式，以下是官方给出的解释： 主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录 自动推送：是轻量级链接提交组件，将自动推送的 JS 代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现 sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送 手动提交：如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度 本人采用的是 sitemap首先我们要使用以下命令生成一个网站地图： bash12npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 这里也注意一下，将根目录的 _config.yml 文件，大约第 17 行处，url 改为在百度站长平台添加的域名，也就是你网站的首页地址： Code1234# URLurl: https:&#x2F;&#x2F;www.mo-yang.toproot: &#x2F;permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; 然后使用命令 hexo g -d 将网站部署上去，然后访问 你的首页/sitemap.xml 或者 你的首页/baidusitemap.xml 就可以看到网站地图了 。 其中 sitemap.xml 文件是搜索引擎通用的 sitemap 文件，baidusitemap.xml 是百度专用的 sitemap 文件 比如我的是： https://mo-yang.top/baidusitemap.xml 或者 https://mo-yang.top/sitemap.xml 然后来到百度站长平台的 sitemap 提交页面，将你的 sitemap 地址提交即可，如果成功的话状态会显示为正常，初次提交要等几分钟，sitemap.xml 相比 baidusitemap.xml 来说等待时间也会更长，如果以后你博客有新的文章或其他页面，可以点击手动更新文件，更新一下新的 sitemap 转载至 https://zhuanlan.zhihu.com/p/100922816","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.mo-yang.top/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"spring基于XML的AOP实现","slug":"spring2","date":"2020-05-23T12:16:27.000Z","updated":"2020-05-23T14:12:43.587Z","comments":true,"path":"2020/05/23/spring2/","link":"","permalink":"https://www.mo-yang.top/2020/05/23/spring2/","excerpt":"","text":"AOP 概述把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。 AOP 的作用及优势作用： 在程序运行期间，不修改源码对已有方法进行增强。 优势： 减少重复代码 提高开发效率维护方便 动态代理的特点 字节码随用随创建，随用随加载。 它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。 装饰者模式就是静态代理的一种体现。 动态代理常用的有两种方式基于接口的动态代理 提供者：JDK 官方的 Proxy 类。 要求：被代理类最少实现一个接口。 基于子类的动态代理提供者：第三方的 CGLib，如果报 asmxxxx 异常，需要导入 asm.jar。 要求：被代理类不能用 final 修饰的类（最终类）。 spring的AOP代码实现使用AOP实现更新日志的功能 进行Maven项目的pom.xmlxml12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;day03_eesy_03springAOP&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建业务层接口cs123456789101112131415161718192021222324package com.itheima.service;/** * 账户的业务层接口 */public interface IAccountService &#123; /** * 模拟保存账户 */ void saveAccount(); /** * 模拟更新账户 * @param i */ void updateAccount(int i); /** * 删除账户 * @return */ int deleteAccount();&#125; 实现业务层接口java1234567891011121314151617181920212223242526package com.itheima.service.impl;import com.itheima.service.IAccountService;/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService&#123; @Override public void saveAccount() &#123; System.out.println(\"执行了保存\"); &#125; @Override public void updateAccount(int i) &#123; System.out.println(\"执行了更新\"+i); &#125; @Override public int deleteAccount() &#123; System.out.println(\"执行了删除\"); return 0; &#125;&#125; 创建通知类arduino1234567891011121314package com.itheima.utils;/** * 用于记录日志的工具类，它里面提供了公共的代码 */public class Logger &#123; /** * 用于打印日志：计划让其在切入点方法执行之前执行（切入点方法就是业务层方法） */ public void printLog()&#123; System.out.println(\"Logger类中的pringLog方法开始记录日志了。。。\"); &#125;&#125; 使用XML配置spring和实现切面xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置srping的Ioc,把service对象配置进来--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;!--spring中基于XML的AOP配置步骤 1、把通知Bean也交给spring来管理 2、使用aop:config标签表明开始AOP的配置 3、使用aop:aspect标签表明配置切面 id属性：是给切面提供一个唯一标识 ref属性：是指定通知类bean的Id。 4、在aop:aspect标签的内部使用对应标签来配置通知的类型 我们现在示例是让printLog方法在切入点方法执行之前之前：所以是前置通知 aop:before：表示配置前置通知 method属性：用于指定Logger类中哪个方法是前置通知 pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强 切入点表达式的写法： 关键字：execution(表达式) 表达式： 访问修饰符 返回值 包名.包名.包名...类名.方法名(参数列表) 标准的表达式写法： public void com.itheima.service.impl.AccountServiceImpl.saveAccount() 访问修饰符可以省略 void com.itheima.service.impl.AccountServiceImpl.saveAccount() 返回值可以使用通配符，表示任意返回值 * com.itheima.service.impl.AccountServiceImpl.saveAccount() 包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*. * *.*.*.*.AccountServiceImpl.saveAccount()) 包名可以使用..表示当前包及其子包 * *..AccountServiceImpl.saveAccount() 类名和方法名都可以使用*来实现通配 * *..*.*() 参数列表： 可以直接写数据类型： 基本类型直接写名称 int 引用类型写包名.类名的方式 java.lang.String 可以使用通配符表示任意类型，但是必须有参数 可以使用..表示有无参数均可，有参数可以是任意类型 全通配写法： * *..*.*(..) 实际开发中切入点表达式的通常写法： 切到业务层实现类下的所有方法 * com.itheima.service.impl.*.*(..) --&gt; &lt;!-- 配置Logger类 --&gt; &lt;bean id=\"logger\" class=\"com.itheima.utils.Logger\"&gt;&lt;/bean&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!--配置切面 --&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!-- 配置通知的类型，并且建立通知方法和切入点方法的关联--&gt; &lt;aop:before method=\"printLog\" pointcut=\"execution(* com.itheima.service.impl.*.*(..))\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 实现测试类swift12345678910111213141516171819202122package com.itheima.test;import com.itheima.service.IAccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 测试AOP的配置 */public class AOPTest &#123; public static void main(String[] args) &#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.获取对象 IAccountService as = (IAccountService)ac.getBean(\"accountService\"); //3.执行方法 as.saveAccount(); as.updateAccount(1); as.deleteAccount(); &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"https://www.mo-yang.top/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.mo-yang.top/tags/spring/"}]},{"title":"mybatis的注解开发","slug":"mybatis3","date":"2020-05-09T08:12:34.000Z","updated":"2020-05-09T14:02:11.422Z","comments":true,"path":"2020/05/09/mybatis3/","link":"","permalink":"https://www.mo-yang.top/2020/05/09/mybatis3/","excerpt":"","text":"mybatis 的注解开发mybatis 的常用注解说明less1234567891011@Insert:实现新增@Update:实现更新@Delete:实现删除@Select:实现查询@Result:实现结果集封装@Results:可以与@Result 一起使用，封装多个结果集@ResultMap:实现引用@Results 定义的封装@One:实现一对一结果集封装@Many:实现一对多结果集封装@SelectProvider: 实现动态SQL映射@CacheNamespace:实现注解二级缓存的使用 使用Mybatis 注解实现基本 CRUD编写实体类arduino1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * * &lt;p&gt;Title: User&lt;/p&gt; * &lt;p&gt;Description: 用户的实体类&lt;/p&gt; */public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return \"User [userId=\" + userId + \", userName=\" + userName + \", userBirthday=\" + userBirthday + \", userSex=\" + userSex + \", userAddress=\" + userAddress + \"]\"; &#125;&#125;注意： 此处故意和数据库表的列名不一致。 使用注解方式开发持久层接口less1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import domain.User;import org.apache.ibatis.annotations.*;import java.util.List;/** * * &lt;p&gt;Title: IUserDao&lt;/p&gt; * &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt; */public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(\"select * from user\") @Results(id=\"userMap\", value= &#123; @Result(id=true,column=\"id\",property=\"userId\"), @Result(column=\"username\",property=\"userName\"), @Result(column=\"sex\",property=\"userSex\"), @Result(column=\"address\",property=\"userAddress\"), @Result(column=\"birthday\",property=\"userBirthday\") &#125;) List&lt;User&gt; findAll(); /** 北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090 传智播客——专注于 Java、.Net 和 Php、网页平面设计工程师的培训 * 根据id 查询一个用户 * @param userId * @return */ @Select(\"select * from user where id = #&#123;uid&#125; \") @ResultMap(\"userMap\") User findById(Integer userId); /** * 保存操作 * @param user * @return */ @Insert(\"insert into user(username,sex,birthday,address)values(#&#123;username&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;)\") @SelectKey(keyColumn=\"id\",keyProperty=\"id\",resultType=Integer.class,before = false, statement = &#123; \"select last_insert_id()\" &#125;) int saveUser(User user);/** * 更新操作 * @param user * @return */ @Update(\"update user set username=#&#123;username&#125;,address=#&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; where id =#&#123;id&#125; \") int updateUser(User user); /** * 删除用户 * @param userId * @return */ @Delete(\"delete from user where id = #&#123;uid&#125; \") int deleteUser(Integer userId); /** * 查询使用聚合函数 * @return */ @Select(\"select count(*) from user \") int findTotal(); /** * 模糊查询 * @param name * @return */ @Select(\"select * from user where username like #&#123;username&#125; \") List&lt;User&gt; findByName(String name);&#125;通过注解方式，我们就不需要再去编写 UserDao.xml 映射文件了。 编写 SqlMapConfig 配置文件dust1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;properties resource=\"jdbcConfig.properties\"&gt;&lt;/properties&gt; &lt;typeAliases&gt; &lt;package name=\"domain\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"mysql\"&gt; &lt;environment id=\"mysql\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- 配置 dao 接口的位置，它有两种方式 第一种：使用mapper 标签配置class 属性 第二种：使用package 标签，直接指定 dao 接口所在的包 --&gt; &lt;package name=\"dao\"&gt;&lt;/package&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写测试方法pgsql123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * * &lt;p&gt;Title: MybatisAnnotationCRUDTest&lt;/p&gt; * &lt;p&gt;Description: mybatis 的注解 crud 测试&lt;/p&gt; */public class MybatisAnnotationCRUDTest &#123; /** * 测试查询所有 */ @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试查询一个 */ @Test public void testFindById() &#123; User user = userDao.findById(41); System.out.println(user); &#125;/** * 测试保存 */ @Test public void testSave() &#123; User user = new User(); user.setUserName(\"mybatis annotation\"); user.setUserSex(\"男\"); user.setUserAddress(\"椒江区\"); user.setUserBirthday(new Date()); int res = userDao.saveUser(user); System.out.println(\"影响数据库记录的行数：\"+res); System.out.println(\"插入的主键值：\"+user.getUserId()); &#125; /** * 测试更新 */ @Test public void testUpdate() &#123; User user = userDao.findById(63); user.setUserBirthday(new Date()); user.setUserSex(\"女\"); int res = userDao.updateUser(user); System.out.println(res); &#125; /** * 测试删除 */ @Test public void testDelete() &#123; int res = userDao.deleteUser(63); System.out.println(res); &#125; /** * 测试查询使用聚合函数 */ @Test public void testFindTotal() &#123; int res = userDao.findTotal(); System.out.println(res); &#125;/** * 测试模糊查询 */ @Test public void testFindByName() &#123; List&lt;User&gt; users = userDao.findByName(\"%m%\"); for(User user : users) &#123; System.out.println(user); &#125; &#125; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before//junit的注解 public void init()throws Exception&#123;//1.读取配置文件 in = Resources.getResourceAsStream(\"SqlMapConfig.xml\");//2.创建工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); factory = builder.build(in);//3.创建 session session = factory.openSession();//4.创建代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//junit 的注解 public void destroy()throws Exception &#123;//提交事务 session.commit();//释放资源 session.close();//关闭流 in.close(); &#125;&#125; 使用注解实现复杂关系映射开发复杂关系映射的注解说明less12345678910111213141516171819202122232425@Results注解 代替的是标签&lt;resultMap&gt; 该注解中可以使用单个@Result注解，也可以使用@Result 集合 @Results（&#123;@Result（），@Result（）&#125;）或@Results（@Result（））@Resutl 注解 代替了 &lt;id&gt;标签和&lt;result&gt;标签 @Result 中 属性介绍： id 是否是主键字段 column 数据库的列名 property 需要装配的属性名 one 需要使用的@One 注解（@Result（one=@One）（））） many 需要使用的@Many注解（@Result（many=@many）（）））@One注解（一对一） 代替了&lt;assocation&gt;标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。@One注解属性介绍： select 指定用来多表查询的 sqlmapper fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。。 使用格式： @Result(column=\" \",property=\"\",one=@One(select=\"\"))@Many注解（多对一） 代替了&lt;Collection&gt;标签,是是多表查询的关键，在注解中用来指定子查询返回对象集合。 注意：聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 javaType （一般为 ArrayList）但是注解中可以不定义； 使用格式： @Result(property=\"\",column=\"\",many=@Many(select=\"\"))","categories":[{"name":"框架","slug":"框架","permalink":"https://www.mo-yang.top/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[]},{"title":"mybatis实现增删改查操作","slug":"mybatis2","date":"2020-05-05T07:47:59.000Z","updated":"2020-05-05T09:04:25.486Z","comments":true,"path":"2020/05/05/mybatis2/","link":"","permalink":"https://www.mo-yang.top/2020/05/05/mybatis2/","excerpt":"","text":"基于代理 Dao 实现 CRUD 操作文件摆放 在持久层接口中添加 增删改等方法pgsql123456789101112131415161718192021222324package dao;import model.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface UserDao &#123;// @Select(\"select * from user\") List&lt;User&gt; findall(); void saveUser(User user); void updateUser(User user); void deleteUser(Integer userId); User findById(Integer userId); List&lt;User&gt; findByName(String username); int findTotal();&#125; 在用户的映射配置文件中配置dust123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"dao.UserDao\"&gt;&lt;!--配置查询所有--&gt;&lt;select id=\"findall\" resultType=\"model.User\"&gt; select * from user &lt;/select&gt; &lt;insert id=\"saveUser\" parameterType=\"model.User\"&gt; insert into user(username,address,sex,birthday) values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;); &lt;/insert&gt; &lt;update id=\"updateUser\" parameterType=\"model.User\"&gt; update user set username = #&#123;username&#125;,address = #&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; where id = #&#123;id&#125;; &lt;/update&gt; &lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; delete from user where id = #&#123;uid&#125;; &lt;/delete&gt;&lt;!-- 根据id查询用户--&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"model.User\"&gt; select * from user where id = #&#123;id&#125;; &lt;/select&gt;&lt;!-- 根据名称模糊查询--&gt; &lt;select id=\"findByName\" parameterType=\"string\" resultType=\"model.User\"&gt;&lt;!-- select * from user where username like #&#123;name&#125;; --&gt; select * from user where username like '%$&#123;value&#125;%'; &lt;/select&gt;&lt;!-- 获取总记录条数--&gt; &lt;select id=\"findTotal\" resultType=\"int\"&gt; select count(id) from user ; &lt;/select&gt;&lt;/mapper&gt; 细节：resultType属性：用于指定结果集的类型。parameterType属性：用于指定传入参数的类型。 sql语句中使用#{}字符：它代表占位符，相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。具体的数据是由#{}里面的内容决定的。#{}中内容的写法：由于数据类型是基本类型，所以此处可以随意写。 模糊查询相关知识点： #{}表示一个占位符号通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，#{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类型值，#{}括号中可以是 value或其它名称。${}表示拼接 sql串通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或 pojo 属性值，如果parameterType传输单个简单类型值，${}括号中只能是 value。 在测试类添加测试pgsql123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package test;import dao.UserDao;import model.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class MybatisTest &#123; private InputStream in; private SqlSession sqlSession; private UserDao userDao; @Before public void init()&#123; in = MybatisTest.class.getClassLoader().getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); sqlSession= factory.openSession(); userDao = sqlSession.getMapper(UserDao.class); &#125; @After public void destroy() throws IOException &#123; // 提交事务 sqlSession.commit(); sqlSession.close(); in.close(); &#125; @Test public void testFindAll() throws IOException &#123;// 1.读取配置文件，加载数据库信息// InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); InputStream in = MybatisTest.class.getClassLoader().getResourceAsStream(\"SqlMapConfig.xml\");// 2.创建SqlsessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in);// 3.使用工厂生产对象 SqlSession session = factory.openSession();// 4.使用Sqlsession创建Dao接口的代理对象 UserDao userDao = session.getMapper(UserDao.class);// 5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findall(); for (User user:users)&#123; System.out.println(user); &#125;// 6.释放资源 session.close(); in.close(); &#125; @Test public void testSave()&#123; User user = new User(); user.setUsername(\"mabits1\"); user.setAddress(\"台州\"); user.setSex(\"男\"); user.setBirthday(new Date()); userDao.saveUser(user); &#125; @Test public void testUpdate()&#123; User user = new User(); user.setId(51); user.setUsername(\"mabits2\"); user.setAddress(\"台州\"); user.setSex(\"男\"); user.setBirthday(new Date()); userDao.updateUser(user); &#125; @Test public void testDelete()&#123; userDao.deleteUser(48); &#125; @Test public void testFindOne()&#123; User user = userDao.findById(51); System.out.println(user); &#125; @Test public void testFindName()&#123;// List&lt;User&gt; users = userDao.findByName(\"%王\"); List&lt;User&gt; users = userDao.findByName(\"王\"); for (User user:users)&#123; System.out.println(user); &#125; &#125; @Test public void testFindTotal()&#123; int count = userDao.findTotal(); System.out.println(count); &#125;&#125; Mybatis 与 JDBC 编程的比较pgsql1234567891011121314151.数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。解决：在 SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。2.Sql语句写在代码中造成代码不易维护，实际应用 sql变化的可能较大，sql 变动需要改变 java代码。解决：将 Sql语句配置在 XXXXmapper.xml文件中与 java 代码分离。3.向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数对应。解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。4.对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。 typeAliases（类型别名）自定义别名：xml12345678在 SqlMapConfig.xml中配置：&lt;typeAliases&gt;&lt;!-- 单个别名定义 --&gt;&lt;typeAlias alias=\"user\" type=\"com.itheima.domain.User\"/&gt;&lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt;&lt;package name=\"com.itheima.domain\"/&gt;&lt;package name=\"其它包\"/&gt;&lt;/typeAliases&gt; mappers（映射器）xml12使用相对于类路径的资源&lt;mapper resource=\"dao/UserDao.xml\"&gt;&lt;/mapper&gt; xml12使用 mapper接口类路径&lt;mapper class=\"dao.UserDao\"&gt;&lt;/mapper&gt; routeros123注册指定包下的所有 mapper 接口 &lt;package name=\"dao\"/&gt;注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。","categories":[],"tags":[]},{"title":"mybatis入门","slug":"mybatis1","date":"2020-04-26T12:59:15.000Z","updated":"2020-04-27T09:28:12.781Z","comments":true,"path":"2020/04/26/mybatis1/","link":"","permalink":"https://www.mo-yang.top/2020/04/26/mybatis1/","excerpt":"","text":"​ mybatis是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql语句本身， 而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 mybatis通过xml 或注解的方式将要执行的各种statement配置起来，并通过java对象和statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并 返回。 采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc进行了封装，屏蔽了 jdbc api 底层访问细节，使我 们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 1.jdbc 程序的回顾jdbc回顾可以查看如下网页查看 https://mo-yang.top/2020/03/13/article6/ jdbc 问题分析pgsql12341、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。2、Sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。 3、使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能 多也可能少，修改 sql 还要修改代码，系统不易维护。 4、对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记 录封装成 pojo 对象解析比较方便。 2.Mybatis入门添加 Mybatis3.4.5 的坐标xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;mybatis1_1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写 User 实体类arduino123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package model;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", username='\" + username + '\\'' + \", birthday=\" + birthday + \", sex='\" + sex + '\\'' + \", address='\" + address + '\\'' + '&#125;'; &#125;&#125; 编写持久层接口的映射文件 IUserDao.xml要求： 创建位置：必须和持久层接口在相同的包中。 名称：必须以持久层接口名称命名文件名，扩展名是.xml xml12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.itheima.dao.IUserDao\"&gt; &lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultType=\"com.itheima.domain.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 编写 SqlMapConfig.xml 配置文件xml12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;!-- 配置环境--&gt; &lt;environments default=\"mysql\"&gt;&lt;!-- 配置mysql环境--&gt; &lt;environment id=\"mysql\"&gt;&lt;!--配置事务类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt;&lt;!-- 配置连接池--&gt; &lt;dataSource type=\"POOLED\"&gt;&lt;!-- 配置链连接数据库的基本信息--&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/imooc?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=UTC\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;!-- resource指定映射文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt;&lt;!-- 注解配置：class指定被注解得dao全限定类名--&gt; &lt;mappers&gt; &lt;mapper resource=\"dao/UserDao.xml\"&gt;&lt;/mapper&gt;&lt;!-- &lt;mapper class=\"dao.UserDao\"&gt;&lt;/mapper&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写测试类pgsql123456789101112131415161718192021222324252627282930313233343536373839package test;import dao.UserDao;import model.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123;// 1.读取配置文件，加载数据库信息// InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); InputStream in = MybatisTest.class.getClassLoader().getResourceAsStream(\"SqlMapConfig.xml\");// 2.创建SqlsessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in);// 3.使用工厂生产对象 SqlSession session = factory.openSession();// 4.使用Sqlsession创建Dao接口的代理对象 UserDao userDao = session.getMapper(UserDao.class);// 5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findall(); for (User user:users)&#123; System.out.println(user); &#125;// 6.释放资源 session.close(); in.close(); &#125;&#125; 3.基于注解的 mybatis 使用在持久层接口中添加注解routeros123456789101112package dao;import model.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface UserDao &#123; @Select(\"select * from user\") List&lt;User&gt; findall();&#125; 修改 SqlMapConfig.xmlxml1234567891011121314151617181920212223242526272829303132配置&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;-- 配置环境--&gt; &lt;environments default=\"mysql\"&gt;-- 配置mysql环境--&gt; &lt;environment id=\"mysql\"&gt;--配置事务类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt;-- 配置连接池--&gt; &lt;dataSource type=\"POOLED\"&gt;-- 配置链连接数据库的基本信息--&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/imooc?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=UTC\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;-- resource指定映射文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt;-- 注解配置：class指定被注解得dao全限定类名--&gt; &lt;mappers&gt;-- &lt;mapper resource=\"dao/UserDao.xml\"&gt;&lt;/mapper&gt;--&gt; &lt;mapper class=\"dao.UserDao\"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注意事项 在使用基于注解的 Mybatis 配置时，请移除 xml 的映射配置（IUserDao.xml）。","categories":[{"name":"框架","slug":"框架","permalink":"https://www.mo-yang.top/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.mo-yang.top/tags/Mybatis/"}]},{"title":"网络编程入门","slug":"java5","date":"2020-04-22T12:52:13.000Z","updated":"2020-04-22T15:10:14.223Z","comments":true,"path":"2020/04/22/java5/","link":"","permalink":"https://www.mo-yang.top/2020/04/22/java5/","excerpt":"","text":"网络编程入门软件结构 C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 网络通信协议 网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。 TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。 协议分类通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。 java.net 包中提供了两种常见的网络协议的支持： UDP：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。 特点:数据被限制在64kb以内，超出这个范围就不能发送了。 数据报(Datagram):网络传输的基本单位 TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。 第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。 ​ 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 网络编程三要素协议 协议：计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。 IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 常用命令 查看本机IP地址，在控制台输入： java1ipconfig 检查网络是否连通，在控制台输入： java12ping 空格 IP地址ping 220.181.57.216 特殊的IP地址 本机IP地址：127.0.0.1、localhost 。 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？ 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。 端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 利用协议+IP地址+端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。 TCP通信程序概述TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。 两端通信时步骤： 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket 类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket 类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 Socket类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法 public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。 小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 构造举例，代码如下： java1Socket client = new Socket(\"127.0.0.1\", 6666); 成员方法 public InputStream getInputStream() ： 返回此套接字的输入流。 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。 关闭生成的InputStream也将关闭相关的Socket。 public OutputStream getOutputStream() ： 返回此套接字的输出流。 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。 关闭生成的OutputStream也将关闭相关的Socket。 public void close() ：关闭此套接字。 一旦一个socket被关闭，它不可再使用。 关闭此socket也将关闭相关的InputStream和OutputStream 。 public void shutdownOutput() ： 禁用此套接字的输出流。 任何先前写出的数据将被发送，随后终止输出流。 2.3 ServerSocket类 ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法 public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。 构造举例，代码如下： java1ServerSocket server = new ServerSocket(6666); 成员方法 public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 简单的TCP网络程序TCP通信分析图解 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 到此，客户端向服务端发送数据成功。 自此，服务端向客户端回写数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Scoket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 客户端向服务器发送数据服务端实现： java12345678910111213141516171819202122public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端启动 , 等待连接 .... \"); // 1.创建 ServerSocket对象，绑定端口，开始等待连接 ServerSocket ss = new ServerSocket(6666); // 2.接收连接 accept 方法, 返回 socket 对象. Socket server = ss.accept(); // 3.通过socket 获取输入流 InputStream is = server.getInputStream(); // 4.一次性读取数据 // 4.1 创建字节数组 byte[] b = new byte[1024]; // 4.2 据读取到字节数组中. int len = is.read(b)； // 4.3 解析数组,打印字符串信息 String msg = new String(b, 0, len); System.out.println(msg); //5.关闭资源. is.close(); server.close(); &#125;&#125; 客户端实现： java1234567891011121314public class ClientTCP &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"客户端 发送数据\"); // 1.创建 Socket ( ip , port ) , 确定连接到哪里. Socket client = new Socket(\"localhost\", 6666); // 2.获取流对象 . 输出流 OutputStream os = client.getOutputStream(); // 3.写出数据. os.write(\"你好么? tcp ,我来了\".getBytes()); // 4. 关闭资源 . os.close(); client.close(); &#125;&#125; 服务器向客户端回写数据服务端实现： java12345678910111213141516171819202122232425262728public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端启动 , 等待连接 .... \"); // 1.创建 ServerSocket对象，绑定端口，开始等待连接 ServerSocket ss = new ServerSocket(6666); // 2.接收连接 accept 方法, 返回 socket 对象. Socket server = ss.accept(); // 3.通过socket 获取输入流 InputStream is = server.getInputStream(); // 4.一次性读取数据 // 4.1 创建字节数组 byte[] b = new byte[1024]; // 4.2 据读取到字节数组中. int len = is.read(b)； // 4.3 解析数组,打印字符串信息 String msg = new String(b, 0, len); System.out.println(msg); // =================回写数据======================= // 5. 通过 socket 获取输出流 OutputStream out = server.getOutputStream(); // 6. 回写数据 out.write(\"我很好,谢谢你\".getBytes()); // 7.关闭资源. out.close(); is.close(); server.close(); &#125;&#125; 客户端实现： java12345678910111213141516171819202122public class ClientTCP &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"客户端 发送数据\"); // 1.创建 Socket ( ip , port ) , 确定连接到哪里. Socket client = new Socket(\"localhost\", 6666); // 2.通过Scoket,获取输出流对象 OutputStream os = client.getOutputStream(); // 3.写出数据. os.write(\"你好么? tcp ,我来了\".getBytes()); // ==============解析回写========================= // 4. 通过Scoket,获取 输入流对象 InputStream in = client.getInputStream(); // 5. 读取数据数据 byte[] b = new byte[100]; int len = in.read(b); System.out.println(new String(b, 0, len)); // 6. 关闭资源 . in.close(); os.close(); client.close(); &#125;&#125; 综合案例文件上传案例文件上传分析图解 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 基本实现服务端实现： java12345678910111213141516171819202122232425public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务器 启动..... \"); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 建立连接 Socket accept = serverSocket.accept(); // 3. 创建流对象 // 3.1 获取输入流,读取文件数据 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); // 3.2 创建输出流,保存到本地 . BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.jpg\")); // 4. 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; //5. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); &#125;&#125; 客户端实现： java12345678910111213141516171819202122232425public class FileUPload_Client &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 创建输入流,读取本地文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"test.jpg\")); // 1.2 创建输出流,写到服务端 Socket socket = new Socket(\"localhost\", 6666); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); //2.写出数据. byte[] b = new byte[1024 * 8 ]; int len ; while (( len = bis.read(b))!=-1) &#123; bos.write(b, 0, len); bos.flush(); &#125; System.out.println(\"文件发送完毕\"); // 3.释放资源 bos.close(); socket.close(); bis.close(); System.out.println(\"文件上传完毕 \"); &#125;&#125; 文件上传优化分析 文件名称写死的问题 服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下： java12FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+\".jpg\") // 文件名称BufferedOutputStream bos = new BufferedOutputStream(fis); 循环接收的问题 服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下： java12345// 每次接收新的连接,创建一个Socketwhile（true）&#123; Socket accept = serverSocket.accept(); ......&#125; 效率问题 服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下： java123456789while（true）&#123; Socket accept = serverSocket.accept(); // accept 交给子线程处理. new Thread(() -&gt; &#123; ...... InputStream bis = accept.getInputStream(); ...... &#125;).start();&#125; 优化实现java12345678910111213141516171819202122232425262728293031323334353637public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务器 启动..... \"); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 循环接收,建立连接 while (true) &#123; Socket accept = serverSocket.accept(); /* 3. socket对象交给子线程处理,进行读写操作 Runnable接口中,只有一个run方法,使用lambda表达式简化格式 */ new Thread(() -&gt; &#123; try ( //3.1 获取输入流对象 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //3.2 创建输出流对象, 保存到本地 . FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(fis);) &#123; // 3.3 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; //4. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 信息回写分析图解前四步与基本文件上传一致. 【服务端】获取输出流，回写数据。 【客户端】获取输入流，解析回写数据。 回写实现java12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务器 启动..... \"); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 循环接收,建立连接 while (true) &#123; Socket accept = serverSocket.accept(); /* 3. socket对象交给子线程处理,进行读写操作 Runnable接口中,只有一个run方法,使用lambda表达式简化格式 */ new Thread(() -&gt; &#123; try ( //3.1 获取输入流对象 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //3.2 创建输出流对象, 保存到本地 . FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(fis); ) &#123; // 3.3 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; // 4.=======信息回写=========================== System.out.println(\"back ........\"); OutputStream out = accept.getOutputStream(); out.write(\"上传成功\".getBytes()); out.close(); //================================ //5. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 客户端实现： java12345678910111213141516171819202122232425262728293031public class FileUpload_Client &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 创建输入流,读取本地文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"test.jpg\")); // 1.2 创建输出流,写到服务端 Socket socket = new Socket(\"localhost\", 6666); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); //2.写出数据. byte[] b = new byte[1024 * 8 ]; int len ; while (( len = bis.read(b))!=-1) &#123; bos.write(b, 0, len); &#125; // 关闭输出流,通知服务端,写出数据完毕 socket.shutdownOutput(); System.out.println(\"文件发送完毕\"); // 3. =====解析回写============ InputStream in = socket.getInputStream(); byte[] back = new byte[20]; in.read(back); System.out.println(new String(back)); in.close(); // ============================ // 4.释放资源 socket.close(); bis.close(); &#125;&#125; 模拟B\\S服务器(扩展知识点)模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。 案例分析 准备页面数据，web文件夹。 复制到我们Module中，比如复制到day08中 我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问 java12345678910public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8000); Socket socket = server.accept(); InputStream in = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = in.read(bytes); System.out.println(new String(bytes,0,len)); socket.close(); server.close();&#125; 服务器程序中字节输入流可以读取到浏览器发来的请求信息 GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。 java12345678//转换流,读取浏览器请求第一行BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream()));String requst = readWb.readLine();//取出请求资源的路径String[] strArr = requst.split(\" \");//去掉web前面的/String path = strArr[1].substring(1);System.out.println(path); 案例实现服务端实现： java1234567891011121314151617181920212223242526272829303132333435public class SerDemo &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端 启动 , 等待连接 .... \"); // 创建ServerSocket 对象 ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); // 转换流读取浏览器的请求消息 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); // 取出请求资源的路径 String[] strArr = requst.split(\" \"); // 去掉web前面的/ String path = strArr[1].substring(1); // 读取客户端请求的资源文件 FileInputStream fis = new FileInputStream(path); byte[] bytes= new byte[1024]; int len = 0 ; // 字节输出流,将文件写会客户端 OutputStream out = socket.getOutputStream(); // 写入HTTP协议响应头,固定写法 out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); out.write(\"Content-Type:text/html\\r\\n\".getBytes()); // 必须要写入空行,否则浏览器不解析 out.write(\"\\r\\n\".getBytes()); while((len = fis.read(bytes))!=-1)&#123; out.write(bytes,0,len); &#125; fis.close(); out.close(); readWb.close(); socket.close(); server.close(); &#125;&#125; 访问效果 火狐 小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。 发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。 浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8888); while(true)&#123; Socket socket = server.accept(); new Thread(new Web(socket)).start(); &#125; &#125; static class Web implements Runnable&#123; private Socket socket; public Web(Socket socket)&#123; this.socket=socket; &#125; public void run() &#123; try&#123; //转换流,读取浏览器请求第一行 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); //取出请求资源的路径 String[] strArr = requst.split(\" \"); System.out.println(Arrays.toString(strArr)); String path = strArr[1].substring(1); System.out.println(path); FileInputStream fis = new FileInputStream(path); System.out.println(fis); byte[] bytes= new byte[1024]; int len = 0 ; //向浏览器 回写数据 OutputStream out = socket.getOutputStream(); out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); out.write(\"Content-Type:text/html\\r\\n\".getBytes()); out.write(\"\\r\\n\".getBytes()); while((len = fis.read(bytes))!=-1)&#123; out.write(bytes,0,len); &#125; fis.close(); out.close(); readWb.close(); socket.close(); &#125;catch(Exception ex)&#123; &#125; &#125; &#125;&#125;","categories":[{"name":"java语法","slug":"java语法","permalink":"https://www.mo-yang.top/categories/java%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://www.mo-yang.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"字节流和字符流","slug":"java4","date":"2020-04-12T13:06:28.000Z","updated":"2020-04-12T13:50:31.057Z","comments":true,"path":"2020/04/12/java4/","link":"","permalink":"https://www.mo-yang.top/2020/04/12/java4/","excerpt":"","text":"IO的分类根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 顶级父类们 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 字节输出流一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 OutputStreamjava.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileOutputStream类OutputStream有很多子类，我们从最简单的一个子类开始。 java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 构造举例，代码如下： java12345678910public class FileOutputStreamConstructor throws IOException &#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileOutputStream fos = new FileOutputStream(file); // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"b.txt\"); &#125;&#125; 写出字节数据 写出字节：write(int b) 方法，每次可以写出一个字节数据，代码使用演示： java1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 写出数据 fos.write(97); // 写出第1个字节 fos.write(98); // 写出第2个字节 fos.write(99); // 写出第3个字节 // 关闭资源 fos.close(); &#125;&#125;输出结果：abc 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示： java1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 字符串转换为字节数组 byte[] b = \"程序员\".getBytes(); // 写出字节数组数据 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;输出结果：程序员 写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码使用演示： java1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 字符串转换为字节数组 byte[] b = \"abcde\".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b,2,2); // 关闭资源 fos.close(); &#125;&#125;输出结果：cd 数据追加续写经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？ public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示： java1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"，true); // 字符串转换为字节数组 byte[] b = \"abcde\".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;文件操作前：cd文件操作后：cdabcde 写出换行Windows系统里，换行符号是\\r\\n 。把 以指定是否追加续写了，代码使用演示： java123456789101112131415161718192021222324public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 定义字节数组 byte[] words = &#123;97,98,99,100,101&#125;; // 遍历数组 for (int i = 0; i &lt; words.length; i++) &#123; // 写出一个字节 fos.write(words[i]); // 写出一个换行, 换行符号转成数组写出 fos.write(\"\\r\\n\".getBytes()); &#125; // 关闭资源 fos.close(); &#125;&#125;输出结果：abcde 回车符\\r和换行符\\n ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\\r\\n； Unix系统里，每行结尾只有 换行 ，即\\n； Mac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一。 字节输入流InputStreamjava.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。 构造方法 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。 构造举例，代码如下： java12345678910public class FileInputStreamConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileInputStream fos = new FileInputStream(file); // 使用文件名称创建流对象 FileInputStream fos = new FileInputStream(\"b.txt\"); &#125;&#125; 读取字节数据 读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码使用演示： java1234567891011121314151617181920212223242526272829public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(\"read.txt\"); // 读取数据，返回一个字节 int read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); // 读取到末尾,返回-1 read = fis.read(); System.out.println( read); // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde-1 循环改进读取方式，代码使用演示： java1234567891011121314151617181920public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(\"read.txt\"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fis.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 虽然读取了一个字节，但是会自动提升为int类型。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示： java12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组变成字符串打印 System.out.println(new String(b)); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcded 错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换，所以要通过len ，获取有效的字节，代码使用演示： java12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b，0，len));// len 每次读取的有效字节个数 &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 字节流练习：图片复制复制原理图解 案例实现复制图片文件，代码使用演示： java123456789101112131415161718192021222324public class Copy &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 指定数据源 FileInputStream fis = new FileInputStream(\"D:\\\\test.jpg\"); // 1.2 指定目的地 FileOutputStream fos = new FileOutputStream(\"test_copy.jpg\"); // 2.读写数据 // 2.1 定义数组 byte[] b = new byte[1024]; // 2.2 定义长度 int len; // 2.3 循环读取 while ((len = fis.read(b))!=-1) &#123; // 2.4 写出数据 fos.write(b, 0 , len); &#125; // 3.关闭资源 fos.close(); fis.close(); &#125;&#125; 小贴士： 流的关闭原则：先开后关，后开先关。 字符输入流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 Readerjava.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。 构造举例，代码如下： java12345678910public class FileReaderConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileReader fr = new FileReader(file); // 使用文件名称创建流对象 FileReader fr = new FileReader(\"b.txt\"); &#125;&#125; 读取字符数据 读取字符：read方法，每次可以读取一个字符的数据，读取到文件末尾，返回-1，循环读取，代码使用演示： java123456789101112131415161718public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(\"read.txt\"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fr.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：程序员 小贴士：虽然读取了一个字符，但是会自动提升为int类型。 使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码使用演示： java12345678910111213141516171819public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(\"read.txt\"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf)); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：程序员序 获取有效的字符改进，代码使用演示： java1234567891011121314151617181920public class FISRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(\"read.txt\"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf,0,len)); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：程序员 字符输出流Writerjava.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 void write(int c) 写入单个字符。 void write(char[] cbuf)写入字符数组。 abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 void write(String str)写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush()刷新该流的缓冲。 void close() 关闭此流，但要先刷新它。 FileWriter类java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。 构造举例，代码如下： java12345678910public class FileWriterConstructor &#123; public static void main(String[] args) throws IOException &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileWriter fw = new FileWriter(file); // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"b.txt\"); &#125;&#125; 基本写出数据写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示： java12345678910111213141516171819public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 写出数据 fw.write(97); // 写出第1个字符 fw.write('b'); // 写出第2个字符 fw.write('C'); // 写出第3个字符 fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。 /* 【注意】关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。 */ // fw.close(); &#125;&#125;输出结果：abC田 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。 flush ：刷新缓冲区，流对象可以继续使用。 close:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 代码使用演示： java1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 写出数据，通过flush fw.write('刷'); // 写出第1个字符 fw.flush(); fw.write('新'); // 继续写出第2个字符，写出成功 fw.flush(); // 写出数据，通过close fw.write('关'); // 写出第1个字符 fw.close(); fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed fw.close(); &#125;&#125; 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。 写出其他数据 写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示： java1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 字符串转换为字节数组 char[] chars = \"神奇程序员\".toCharArray(); // 写出字符数组 fw.write(chars); // 神奇程序员 // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。 fw.write(b,2,2); // 程序 // 关闭资源 fos.close(); &#125;&#125; 写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，代码使用演示： java1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 字符串 String msg = \"神奇程序员\"; // 写出字符数组 fw.write(msg); //神奇程序员 // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。 fw.write(msg,2,2); // 程序 // 关闭资源 fos.close(); &#125;&#125; 续写和换行：操作类似于FileOutputStream。 java1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象，可以续写数据 FileWriter fw = new FileWriter(\"fw.txt\"，true); // 写出字符串 fw.write(\"神奇\"); // 写出换行 fw.write(\"\\r\\n\"); // 写出字符串 fw.write(\"程序员\"); // 关闭资源 fw.close(); &#125;&#125;输出结果:神奇程序员 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流 Propertiesjava.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。 Properties类构造方法 public Properties() :创建一个空的属性列表。 基本的存储方法 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 java12345678910111213141516171819202122232425262728293031public class ProDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 创建属性集对象 Properties properties = new Properties(); // 添加键值对元素 properties.setProperty(\"filename\", \"a.txt\"); properties.setProperty(\"length\", \"209385038\"); properties.setProperty(\"location\", \"D:\\\\a.txt\"); // 打印属性集对象 System.out.println(properties); // 通过键,获取属性值 System.out.println(properties.getProperty(\"filename\")); System.out.println(properties.getProperty(\"length\")); System.out.println(properties.getProperty(\"location\")); // 遍历属性集,获取所有键的集合 Set&lt;String&gt; strings = properties.stringPropertyNames(); // 打印键值对 for (String key : strings ) &#123; System.out.println(key+\" -- \"+properties.getProperty(key)); &#125; &#125;&#125;输出结果：&#123;filename=a.txt, length=209385038, location=D:\\a.txt&#125;a.txt209385038D:\\a.txtfilename -- a.txtlength -- 209385038location -- D:\\a.txt 与流相关的方法 public void load(InputStream inStream)： 从字节输入流中读取键值对。 参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式: ini123filename=a.txtlength=209385038location=D:\\a.txt 加载代码演示： java1234567891011121314151617public class ProDemo2 &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 创建属性集对象 Properties pro = new Properties(); // 加载文本中信息到属性集 pro.load(new FileInputStream(\"read.txt\")); // 遍历集合并打印 Set&lt;String&gt; strings = pro.stringPropertyNames(); for (String key : strings ) &#123; System.out.println(key+\" -- \"+pro.getProperty(key)); &#125; &#125;&#125;输出结果：filename -- a.txtlength -- 209385038location -- D:\\a.txt 小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。","categories":[{"name":"java语法","slug":"java语法","permalink":"https://www.mo-yang.top/categories/java%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"字符流","slug":"字符流","permalink":"https://www.mo-yang.top/tags/%E5%AD%97%E7%AC%A6%E6%B5%81/"},{"name":"字节流","slug":"字节流","permalink":"https://www.mo-yang.top/tags/%E5%AD%97%E8%8A%82%E6%B5%81/"}]},{"title":"Junit和Class对象","slug":"java3","date":"2020-04-05T12:55:39.000Z","updated":"2020-04-05T13:09:49.599Z","comments":true,"path":"2020/04/05/java3/","link":"","permalink":"https://www.mo-yang.top/2020/04/05/java3/","excerpt":"","text":"这段时间在家是真的闲的发慌，自我感觉最近学习状态都不怎么高涨了，还是希望赶紧开学吧。日常的对本周的Java学习进行总结。 1.Junit单元测试markdown12345678910111213141516171819202122232425262728293031* 测试分类： 1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 2. 白盒测试：需要写代码的。关注程序具体的执行流程。* Junit使用：白盒测试 * 步骤： 1. 定义一个测试类(测试用例) * 建议： * 测试类名：被测试的类名Test CalculatorTest * 包名：xxx.xxx.xx.test cn.itcast.test 2. 定义测试方法：可以独立运行 * 建议： * 方法名：test测试的方法名 testAdd() * 返回值：void * 参数列表：空参 3. 给方法加@Test 4. 导入junit依赖环境 * 判定结果： * 红色：失败 * 绿色：成功 * 一般我们会使用断言操作来处理结果 * Assert.assertEquals(期望的结果,运算的结果); * 补充： * @Before: * 修饰的方法会在测试方法之前被自动执行 * @After: * 修饰的方法会在测试方法执行之后自动被执行 2.反射：框架设计的灵魂 反射：将类的各个组成部分封装为其他对象，这就是反射机制 好处： 可以在程序运行过程中，操作这些对象。 可以解耦，提高程序的可扩展性。 stata12345678910* 获取Class对象的方式： 1. Class.forName(\"全类名\")：将字节码文件加载进内存，返回Class对象 * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 2. 类名.class：通过类名的属性class获取 * 多用于参数的传递 3. 对象.getClass()：getClass()方法在Object类中定义着。 * 多用于对象的获取字节码的方式 * 结论： 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 Class对象功能： 获取功能： 获取成员变量们 Field[] getFields() ：获取所有public修饰的成员变量 Field getField(String name) 获取指定名称的 public修饰的成员变量 Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name) markdown123456789* Field：成员变量 * 操作： 1. 设置值 * void set(Object obj, Object value) 2. 获取值 * get(Object obj) 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor getConstructor(类&lt;?&gt;… parameterTypes) Constructor getDeclaredConstructor(类&lt;?&gt;… parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() delphi12345* Constructor:构造方法 * 创建对象： * T newInstance(Object... initargs) * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 获取成员方法们： Method[] getMethods() Method getMethod(String name, 类&lt;?&gt;… parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) oxygene123456* Method：方法对象 * 执行方法： * Object invoke(Object obj, Object... args) * 获取方法名称： * String getName:获取方法名 ​4. 获取全类名 * String getName()","categories":[{"name":"java语法","slug":"java语法","permalink":"https://www.mo-yang.top/categories/java%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Junit","slug":"Junit","permalink":"https://www.mo-yang.top/tags/Junit/"},{"name":"反射","slug":"反射","permalink":"https://www.mo-yang.top/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Collection下的List和Set","slug":"java2","date":"2020-04-05T11:10:34.000Z","updated":"2020-04-05T13:13:35.909Z","comments":true,"path":"2020/04/05/java2/","link":"","permalink":"https://www.mo-yang.top/2020/04/05/java2/","excerpt":"","text":"1. 集合 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map。 JDK中提供了丰富的集合类库,我们来通过一张图来描述整个集合类的继承体系。 其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。 1.1 Collection 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 1.2 Iterator迭代器在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 Iterator接口的常用方法如下： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 arduino12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(\"串串星人\"); coll.add(\"吐槽星人\"); coll.add(\"汪星人\"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，接下来通过一个图例来演示Iterator对象迭代元素的过程： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 2. List接口2.1 List集合介绍java.util.List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地会将实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 2.2 List接口中常用方法 public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 2.3 List的子类2.3.1 ArrayList集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快。 2.3.2 LinkedList集合java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 3. Set集合java.util.Set接口和java.util.List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。与List接口不同的是，Set接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。 3.1 HashSet集合介绍java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 总而言之，JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 4.Collections java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 angelscript12345678910111213141516171819public class CollectionsDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //原来写法 //list.add(12); //list.add(14); //list.add(15); //list.add(1000); //采用工具类 完成 往集合中添加元素 Collections.addAll(list, 5, 222, 1，2); System.out.println(list); //排序方法 Collections.sort(list); System.out.println(list); &#125;&#125;结果：[5, 222, 1, 2][1, 2, 5, 222]","categories":[{"name":"java语法","slug":"java语法","permalink":"https://www.mo-yang.top/categories/java%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"数据库连接池DataSource和JDBC Template","slug":"jdbc2","date":"2020-04-02T01:16:44.000Z","updated":"2020-04-02T04:40:44.619Z","comments":true,"path":"2020/04/02/jdbc2/","link":"","permalink":"https://www.mo-yang.top/2020/04/02/jdbc2/","excerpt":"","text":"1.数据库连接池1.概念：其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 2.好处： 节约资源 用户访问高效 3.实现： 标准接口：DataSource javax.sql包下的 方法： 获取连接：getConnection() 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接* 一般我们不去实现它，有数据库厂商来实现 C3P0：数据库连接池技术 Druid：数据库连接池实现技术，由阿里巴巴提供的 4.C3P0：数据库连接池技术angelscript123456789101112131415 * 步骤： 1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， * 不要忘记导入数据库驱动jar包 2. 定义配置文件： * 名称： c3p0.properties 或者 c3p0-config.xml * 路径：直接将文件放在src目录下即可。 3. 创建核心对象 数据库连接池对象 ComboPooledDataSource 4. 获取连接： getConnection* 代码： //1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); c3p0-config.xmlxml1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;c3p0-config&gt;&lt;default-config&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/shopping?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=UTC&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;123456&lt;/property&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;240&lt;/property&gt; &lt;property name=\"checkoutTimeout\"&gt;60000&lt;/property&gt; &lt;property name=\"acquireIncrement\"&gt;1&lt;/property&gt;&lt;/default-config&gt;&lt;/c3p0-config&gt; 5.Druid：数据库连接池实现技术，由阿里巴巴提供1.步骤 1. 导入jar包 druid-1.0.9.jar 2. 定义配置文件： * 是properties形式的 * 可以叫任意名称，可以放在任意目录下 3. 加载配置文件。Properties 4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 5. 获取连接：getConnection * 代码： //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); 2. 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法 * 代码： public class JDBCUtils { //1.定义成员变量 DataSource private static DataSource ds ; static{ try { //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } /** * 释放资源 */ public static void close(Statement stmt,Connection conn){ /* if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } }*/ close(null,stmt,conn); }​ public static void close(ResultSet rs , Statement stmt, Connection conn){ if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } } } /** * 获取连接池方法 */ public static DataSource getDataSource(){ return ds; } }druid.propertiesini1234567driverClassName = com.mysql.cj.jdbc.Driverurl = jdbc:mysql://localhost:3306/shopping?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTCusername = rootpassword = 123456initialSize = 5maxActieve = 240maxWait = 60000 2.Spring JDBC* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 * 步骤： 1. 导入jar包 2. 创建JdbcTemplate对象。依赖于数据源DataSource * JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 * update():执行DML语句。增、删、改语句 * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 * 注意：这个方法查询的结果集长度只能是1 * queryForList():查询结果将结果集封装为list集合 * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 * query():查询结果，将结果封装为JavaBean对象 * query的参数：RowMapper * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 * new BeanPropertyRowMapper&lt;类型&gt;(类型.class) * queryForObject：查询结果，将结果封装为对象 * 一般用于聚合函数的查询 4. 练习： * 需求： 1. 修改1号数据的 salary 为 10000 2. 添加一条记录 3. 删除刚才添加的记录 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数 * 代码： import cn.itcast.domain.Emp; import cn.itcast.utils.JDBCUtils; import org.junit.Test; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import java.sql.Date; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Map; public class JdbcTemplateDemo2 { //Junit单元测试，可以让方法独立执行​ //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1(){ //2. 定义sql String sql = &quot;update emp set salary = 10000 where id = 1001&quot;; //3. 执行sql int count = template.update(sql); System.out.println(count); } /** * 2. 添加一条记录 */ @Test public void test2(){ String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;; int count = template.update(sql, 1015, &quot;郭靖&quot;, 10); System.out.println(count); } /** * 3.删除刚才添加的记录 */ @Test public void test3(){ String sql = &quot;delete from emp where id = ?&quot;; int count = template.update(sql, 1015); System.out.println(count); } /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4(){ String sql = &quot;select * from emp where id = ? or id = ?&quot;; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20} } /** * 5. 查询所有记录，将其封装为List */ @Test public void test5(){ String sql = &quot;select * from emp&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) { System.out.println(stringObjectMap); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() { @Override public Emp mapRow(ResultSet rs, int i) throws SQLException { Emp emp = new Emp(); int id = rs.getInt(&quot;id&quot;); String ename = rs.getString(&quot;ename&quot;); int job_id = rs.getInt(&quot;job_id&quot;); int mgr = rs.getInt(&quot;mgr&quot;); Date joindate = rs.getDate(&quot;joindate&quot;); double salary = rs.getDouble(&quot;salary&quot;); double bonus = rs.getDouble(&quot;bonus&quot;); int dept_id = rs.getInt(&quot;dept_id&quot;); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; } }); for (Emp emp : list) { System.out.println(emp); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) { System.out.println(emp); } } /** * 7. 查询总记录数 */ @Test public void test7(){ String sql = &quot;select count(id) from emp&quot;; Long total = template.queryForObject(sql, Long.class); System.out.println(total); } }","categories":[{"name":"jsp","slug":"jsp","permalink":"https://www.mo-yang.top/categories/jsp/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://www.mo-yang.top/tags/JavaWeb/"}]},{"title":"使用p3c0时候的奇怪错误","slug":"cai2","date":"2020-03-30T10:38:40.000Z","updated":"2020-03-30T12:00:50.924Z","comments":true,"path":"2020/03/30/cai2/","link":"","permalink":"https://www.mo-yang.top/2020/03/30/cai2/","excerpt":"","text":"今天在看c3p0连接池的时候，因为连接数据库疯狂报错 routeros1com.mchange.v2.resourcepool.TimeoutException: A client timed out while waiting to acquire a resource from com.mchange.v2.resourcepool.BasicResourcePool@1c83354 -- timeout at awaitAvailable() 最后查了百度谷歌等，发现谷歌是真的好用啊！！！ 最后找到了解决办法如下： xml1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;c3p0-config&gt;&lt;default-config&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/shopping?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=UTC&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;123456&lt;/property&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;240&lt;/property&gt; &lt;property name=\"checkoutTimeout\"&gt;60000&lt;/property&gt; &lt;property name=\"acquireIncrement\"&gt;1&lt;/property&gt;&lt;/default-config&gt;&lt;/c3p0-config&gt; 配置的时候checkoutTimeout这个属性还是不够大，导致连接池还没获取到连接就自动暂停了。 把这个属性的值从3000改成60000就可以了。","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://www.mo-yang.top/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"java进阶知识","slug":"java1","date":"2020-03-29T13:55:36.000Z","updated":"2020-03-29T15:55:01.232Z","comments":true,"path":"2020/03/29/java1/","link":"","permalink":"https://www.mo-yang.top/2020/03/29/java1/","excerpt":"","text":"由于感觉到自身java基础的不足，所以打算完善下基础。 1.Java虚拟机——JVMJVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系 统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM 运行在操作系统上。 JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。 JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 2.Object类java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： java123public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个： public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 2.2 toString方法方法摘要 public String toString()：返回该对象的字符串表示。 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： java1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 2.3 equals方法方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： java1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。 3.StringBuilder类3.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： java1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s = \"Hello\"; s += \"World\"; System.out.println(s); &#125;&#125; 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即&quot;Hello&quot;、&quot;World&quot;和&quot;HelloWorld&quot;。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWord 。 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 3.2 StringBuilder概述查阅java.lang.StringBuilder的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 3.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 java123456789public class StringBuilderDemo &#123; public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(\"itcast\"); System.out.println(sb2); // itcast &#125;&#125; 3.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： java12345678910111213141516171819202122public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append(\"hello\"); //对比一下 System.out.println(\"builder:\"+builder); System.out.println(\"builder2:\"+builder2); System.out.println(builder == builder2); //true // 可以添加 任何类型 builder.append(\"hello\"); builder.append(\"world\"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append(\"hello\").append(\"world\").append(true).append(100); System.out.println(\"builder:\"+builder); &#125;&#125; 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： java123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125;","categories":[{"name":"java语法","slug":"java语法","permalink":"https://www.mo-yang.top/categories/java%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"java基础和进阶","slug":"java基础和进阶","permalink":"https://www.mo-yang.top/tags/java%E5%9F%BA%E7%A1%80%E5%92%8C%E8%BF%9B%E9%98%B6/"}]},{"title":"异常和线程基础","slug":"threading","date":"2020-03-22T11:00:04.000Z","updated":"2020-03-22T12:57:52.960Z","comments":true,"path":"2020/03/22/threading/","link":"","permalink":"https://www.mo-yang.top/2020/03/22/threading/","excerpt":"","text":"【异常、线程】这几天由于在做项目的时候需要了解线程的调度，虽然对线程以前有所接触，但是从未系统学习过。这几天对线程进行了完善的学习，顺带对异常的处理也相应进行了系统性的了解。 第一章 异常1.1 异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 1.2 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 1.3 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) 1.4 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。 工具类 java1234567public class ArrayTools &#123; // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element; &#125;&#125; 测试类 java12345678public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 34, 12, 67 &#125;; intnum = ArrayTools.getElement(arr, 4) System.out.println(\"num=\" + num); System.out.println(\"over\"); &#125;&#125; 上述程序执行过程图解： 第二章 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 2.1 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： haxe1throw new 异常类名(参数); 例如： java123throw new NullPointerException(\"要访问的arr数组不存在\");throw new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 java123456789101112131415161718192021222324252627public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(\"over\"); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了~~~\"); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 2.2 Objects非空判断还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： java12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 2.3 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： angelscript1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 声明异常的代码演示： java12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read(\"a.txt\"); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 java123456789101112131415public class ThrowsDemo2 &#123; public static void main(String[] args) throws IOException &#123; read(\"a.txt\"); &#125; public static void read(String path)throws FileNotFoundException, IOException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; if (!path.equals(\"b.txt\")) &#123; throw new IOException(); &#125; &#125;&#125; 2.4 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： java123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： java123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(\"b.txt\"); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 2.4 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： java1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(\"a.txt\"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(\"不管程序怎样，这里都将会被执行。\"); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 2.5 异常注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： java123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 第三章 自定义异常3.1 概述为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 3.2 自定义异常的练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： java12345678910111213141516// 业务逻辑异常public class RegisterException extends Exception &#123; /** * 空参构造 */ public RegisterException() &#123; &#125; /** * * @param message 表示异常提示 */ public RegisterException(String message) &#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 java123456789101112131415161718192021222324252627public class Demo &#123; // 模拟数据库中已存在账号 private static String[] names = &#123;\"bill\",\"hill\",\"jill\"&#125;; public static void main(String[] args) &#123; //调用方法 try&#123; // 可能出现异常的代码 checkUsername(\"nill\"); System.out.println(\"注册成功\");//如果没有异常就是注册成功 &#125;catch(RegisterException e)&#123; //处理异常 e.printStackTrace(); &#125; &#125; //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException&#123; for (String name : names) &#123; if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常 throw new RegisterException(\"亲\"+name+\"已经被注册了！\"); &#125; &#125; return true; &#125;&#125; 第四章 多线程我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述问题,咱们得使用多进程或者多线程来解决. 4.1 并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 4.2 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程： 进程 线程 线程调度: 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 4.3 创建线程类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码如下： 测试类： java123456789101112public class Demo01 &#123; public static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread(\"新的线程！\"); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"main线程！\"+i); &#125; &#125;&#125; 自定义线程类： java12345678910111213141516public class MyThread extends Thread &#123; //定义指定线程名称的构造方法 public MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name); &#125; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName()+\"：正在执行！\"+i); &#125; &#125;&#125;","categories":[{"name":"java语法","slug":"java语法","permalink":"https://www.mo-yang.top/categories/java%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://www.mo-yang.top/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"异常","slug":"异常","permalink":"https://www.mo-yang.top/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"那些年我踩过的坑","slug":"cai","date":"2020-03-16T07:04:05.000Z","updated":"2020-03-16T07:25:57.015Z","comments":true,"path":"2020/03/16/cai/","link":"","permalink":"https://www.mo-yang.top/2020/03/16/cai/","excerpt":"","text":"最近这两天，由于切实的感觉到gitalk评论系统实在是太慢了，就想换一个。 由于 来必力（LiveRe） Disqus 和gitalk一个德性 加载速度贼慢，甚至有被墙的可能，寻觅了很久之后， 选择了valine系统。 然后，经过一番常规操作之后，在加载上valine之后，疯狂报错。 如下图 此处的我默默的流下伤心的泪水。 然而经过我翻墙后在谷歌坚持不懈地寻找，最后终于找到了解决方法。 右键检查发现 这该死的，居然把注释也给获取了。找到主题下的_config.yml，删掉注释重新部署就可以完成了 。 如果还没解决的话可以试试切换leancloud节点，我这里是华北节点，创建class 。","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://www.mo-yang.top/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"spring之数据库增删改查","slug":"article8","date":"2020-03-15T13:05:55.000Z","updated":"2020-03-15T13:36:05.630Z","comments":true,"path":"2020/03/15/article8/","link":"","permalink":"https://www.mo-yang.top/2020/03/15/article8/","excerpt":"","text":"基于junit和mysql的spring开发1.持久层实现类java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.dao.impl;import com.dao.IAccountDao;import com.domain.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.SQLException;import java.util.List;//账户持久层实现类public class AccountDaoImpl implements IAccountDao &#123; private QueryRunner runner; public void setRunner(QueryRunner runner) &#123; this.runner = runner; &#125; public List&lt;Account&gt; findAllAccount() &#123; try &#123; return runner.query(\"select * from account\",new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public Account findAccountById(Integer accountId) &#123; try &#123; return runner.query(\"select * from account where id = ? \",new BeanHandler&lt;Account&gt;(Account.class),accountId); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public void saveAccount(Account account) &#123; try &#123; runner.update(\"insert into account(name,money) values(?,?)\",account.getName(),account.getMoney()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public void updateAccount(Account account) &#123; try &#123; runner.update(\"update account set name=?,money=? where id=?\",account.getName(),account.getMoney(),account.getId()); &#125;catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public void deleteAccount(Integer accountId) &#123; try &#123; runner.update(\"delete from account where id = ?\",accountId); &#125;catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 2.账户类pgsql123456789101112131415161718192021222324252627282930313233343536373839404142package com.domain;import java.io.Serializable;public class Account implements Serializable &#123; private Integer id; private String name; private Float money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; @Override public String toString() &#123; return \"Account&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", money=\" + money + '&#125;'; &#125;&#125; 3.业务层实现类aspectj1234567891011121314151617181920212223242526272829303132333435363738package com.service.impl;import com.dao.IAccountDao;import com.domain.Account;import com.service.IAccountService;import java.util.List;//账户业务层实现类public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public List&lt;Account&gt; findAllAccount() &#123; return accountDao.findAllAccount(); &#125; public Account findAccountById(Integer accountId) &#123; return accountDao.findAccountById(accountId); &#125; public void saveAccount(Account account) &#123; accountDao.saveAccount(account); &#125; public void updateAccount(Account account) &#123; accountDao.updateAccount(account); &#125; public void deleteAccount(Integer accountId) &#123; accountDao.deleteAccount(accountId); &#125;&#125; 4.bean.xml创建bean和数据库驱动 applescript1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"accountDao\" class=\"com.dao.impl.AccountDaoImpl\"&gt; &lt;property name=\"runner\" ref=\"runner\"&gt;&lt;/property&gt; &lt;/bean&gt;-- 配置QueryRunner--&gt; &lt;bean id=\"runner\" class=\"org.apache.commons.dbutils.QueryRunner\" scope=\"prototype\"&gt;-- 注入数据源--&gt; &lt;constructor-arg name=\"ds\" ref=\"dataSource\" &gt;&lt;/constructor-arg&gt; &lt;/bean&gt;-- 配置数据源--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/eesy?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=UTC\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4.junit实现的测试类reasonml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.test;import com.domain.Account;import com.service.IAccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;//使用junit单元测试public class AccountServioceTest &#123; @Test public void testFindAll() &#123;// 1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 List&lt;Account&gt; accountcs = as.findAllAccount(); for (Account account : accountcs)&#123; System.out.println(account); &#125; &#125; @Test public void testFindOne() &#123; // 1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 Account account =as.findAccountById(1); System.out.println(account); &#125; @Test public void testSave() &#123; Account account =new Account(); account.setName(\"test\"); account.setMoney(12345f); ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 as.saveAccount(account);// System.out.println(account); &#125; @Test public void testUpdate() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 Account account = as.findAccountById(4); account.setMoney(23456f); as.updateAccount(account); &#125; @Test public void testDelete() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// 2.得到业务层对象 IAccountService as = ac.getBean(\"accountService\",IAccountService.class);// 执行方法 as.deleteAccount(4); &#125;&#125; 5.设置导入包的坐标–pom.xmlxml12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;springday02_02&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;","categories":[{"name":"框架","slug":"框架","permalink":"https://www.mo-yang.top/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.mo-yang.top/tags/spring/"},{"name":"三层架构","slug":"三层架构","permalink":"https://www.mo-yang.top/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"}]},{"title":"spring之注解配置","slug":"article7","date":"2020-03-15T11:50:50.000Z","updated":"2020-03-15T13:02:37.804Z","comments":true,"path":"2020/03/15/article7/","link":"","permalink":"https://www.mo-yang.top/2020/03/15/article7/","excerpt":"","text":"1.基于注解配置的bean.xml的约束条件xml1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; 依赖中需要aop的jar包 告知spring在创建容器需要的包，配置标签在context的名称空间和约束中 &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 2.注解配置创建Bean加入Ioc容器*曾经XML的配置：monkey12345* &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"* scope=\"\" init-method=\"\" destroy-method=\"\"&gt;* &lt;property name=\"\" value=\"\" | ref=\"\"&gt;&lt;/property&gt;* &lt;/bean&gt; *使用注解配置1.用于创建对象的stata123456789101112131415161718192021222324252627282930 * 他们的作用就和在XML配置文件中编写一个&lt;bean&gt;标签实现的功能是一样的 * Component: * 作用：用于把当前类对象存入spring容器中 * 属性： * value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。 * Controller：一般用在表现层 * Service：一般用在业务层 * Repository：一般用在持久层 * 以上三个注解他们的作用和属性与Component是一模一样。 * 他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰 *package com.itheima.dao.impl;import com.itheima.dao.IAccountDao;import org.springframework.stereotype.Repository;/** * 账户的持久层实现类 */@Repository(\"accountDao1\")public class AccountDaoImpl implements IAccountDao &#123; public void saveAccount()&#123; System.out.println(\"保存了账户1111111111111\"); &#125;&#125; 2.用于注入数据的gams1234567891011121314151617181920212223242526* 他们的作用就和在xml配置文件中的bean标签中写一个&lt;property&gt;标签的作用是一样的* Autowired:* 作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功* 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。* 如果Ioc容器中有多个类型匹配时：* 出现位置：* 可以是变量上，也可以是方法上* 细节：* 在使用注解注入时，set方法就不是必须的了。* Qualifier:* 作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以* 属性：* value：用于指定注入bean的id。* Resource* 作用：直接按照bean的id注入。它可以独立使用* 属性：* name：用于指定bean的id。* 以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。* 另外，集合类型的注入只能通过XML来实现。** Value* 作用：用于注入基本类型和String类型的数据* 属性：* value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式）* SpEL的写法：$&#123;表达式&#125;* 3.用于改变作用范围的asciidoc123456789101112* 他们的作用就和在bean标签中使用scope属性实现的功能是一样的* Scope* 作用：用于指定bean的作用范围* 属性：* value：指定范围的取值。常用取值：singleton prototype** 和生命周期相关 了解* 他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的* PreDestroy* 作用：用于指定销毁方法* PostConstruct* 作用：用于指定初始化方法 3.业务层代码实现crystal12345678910111213141516171819202122232425262728293031323334353637package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.service.IAccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;import javax.annotation.Resource;@Component//@Service(\"accountService\")//@Scope(\"prototype\")public class AccountServiceImpl implements IAccountService &#123;// @Autowired// @Qualifier(\"accountDao1\") @Resource(name = \"accountDao2\") private IAccountDao accountDao = null; @PostConstruct public void init()&#123; System.out.println(\"初始化方法执行了\"); &#125; @PreDestroy public void destroy()&#123; System.out.println(\"销毁方法执行了\"); &#125; public void saveAccount()&#123; accountDao.saveAccount(); &#125;&#125; 4.创建容器调用业务层pgsql1234567891011121314151617181920212223242526272829package com.itheima.ui;import com.itheima.dao.IAccountDao;import com.itheima.service.IAccountService;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 模拟一个表现层，用于调用业务层 */public class Client &#123; /** * @param args */ public static void main(String[] args) &#123; //1.获取核心容器对象// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取Bean对象 IAccountService as = (IAccountService)ac.getBean(\"accountServiceImpl\");// IAccountService as2 = (IAccountService)ac.getBean(\"accountService\"); System.out.println(as);// IAccountDao adao = ac.getBean(\"accountDao\",IAccountDao.class);// System.out.println(adao);// System.out.println(as == as2); as.saveAccount(); ac.close(); &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"https://www.mo-yang.top/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.mo-yang.top/tags/spring/"}]},{"title":"JDBC入门","slug":"article6","date":"2020-03-13T05:33:07.000Z","updated":"2020-03-13T06:49:49.974Z","comments":true,"path":"2020/03/13/article6/","link":"","permalink":"https://www.mo-yang.top/2020/03/13/article6/","excerpt":"","text":"1. JDBC基本概念 2. JDBC基本使用 3. 对JDBC中各个接口和类详解JDBC：1. 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 2. 快速入门： * 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql 5. 获取执行sql语句的对象 Statement 6. 执行sql，接受返回结果 7. 处理结果 8. 释放资源 * 代码实现： //1. 导入驱动jar包 //2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/shopping?useUnicode=true&amp;characterEncoding=utf8&quot;,&quot;root&quot;,&quot;****&quot;); //4.定义sql语句 String sql = &quot;update account set balance = 500 where id = 1&quot;; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); 3. 详解各个对象： 1. DriverManager：驱动管理对象 * 功能： 1. 注册驱动：告诉程序该使用哪一个数据库驱动jar static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); } } 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2. 获取数据库连接： * 方法：static Connection getConnection(String url, String user, String password) * 参数： * url：指定连接的路径 * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称?useUnicode=true&amp;characterEncoding=utf8 * 例子：jdbc:mysql://localhost:3306/shopping?useUnicode=true&amp;characterEncoding=utf8 * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 * user：用户名 * password：密码 2. Connection：数据库连接对象 1. 功能： 1. 获取执行sql 的对象 * Statement createStatement() * PreparedStatement prepareStatement(String sql) 2. 管理事务： * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 提交事务：commit() * 回滚事务：rollback() 3. Statement：执行sql的对象 1. 执行sql 1. boolean execute(String sql) ：可以执行任意的sql 了解 2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 3. ResultSet executeQuery(String sql) ：执行DQL（select)语句 2. 练习： package cn; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Statement; public class jdbc2 { public static void main(String[] args) { Statement stmt = null; Connection conn =null; // 1.注册驱动 try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 2.定义sql // INSERT INTO `items` VALUES (&apos;1&apos;, &apos;沃特篮球鞋&apos;, &apos;佛山&apos;, &apos;180&apos;, &apos;500&apos;, &apos;001.jpg&apos;); String sql = &quot;INSERT INTO `items` VALUES (&apos;11&apos;, &apos;篮球鞋&apos;, &apos;佛山&apos;, &apos;180&apos;, &apos;500&apos;, &apos;011.jpg&apos;)&quot;; // 获取connection对象 conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/shopping?useUnicode=true&amp;characterEncoding=utf8&quot;,&quot;root&quot;,&quot;123456&quot;); // 4.获取执行sql对象 stmt = conn.createStatement(); // 5.执行sql int count = stmt.executeUpdate(sql); System.out.println(count); if (count&gt;0) System.out.println(&quot;添加成功&quot;); } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { // 避免空指针异常 if (stmt!=null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } 4. ResultSet：结果集对象,封装查询结果 * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true * getXxx(参数):获取数据 * Xxx：代表数据类型 如： int getInt() , String getString() * 参数： 1. int：代表列的编号,从1开始 如： getString(1) 2. String：代表列名称。 如： getDouble(&quot;balance&quot;) * 注意： * 使用步骤： 1. 游标向下移动一行 2. 判断是否有数据 3. 获取数据 //循环判断游标是否是最后一行末尾。 while(rs.next()){ //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(&quot;name&quot;); double balance = rs.getDouble(3); System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance); } 5. PreparedStatement：执行sql的对象(使用较多) 1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 1. 输入用户随便，输入密码：a&apos; or &apos;a&apos; = &apos;a 2. sql：select * from user where username = &apos;fhdsjkf&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos; 2. 解决sql注入问题：使用PreparedStatement对象来解决 3. 预编译的SQL：参数使用?作为占位符 4. 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 5. 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 6. 给？赋值： * 方法： setXxx(参数1,参数2) * 参数1：？的位置编号 从1 开始 * 参数2：？的值 7. 执行sql，接受返回结果，不需要传递sql语句 8. 处理结果 9. 释放资源 案例代码: /** * 练习：jdbc+jdbcutils+mysql * * 需求： * 1. 通过键盘录入用户名和密码 * 2. 判断用户是否登录成功 */ package cn.itcast.jdbc; import cn.itcast.util.JDBCUtils; import java.sql.*; import java.util.Scanner; public class JDBCDemo9 { public static void main(String[] args) { //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String password = sc.nextLine(); //2.调用方法 boolean flag = new JDBCDemo9().login2(username, password); //3.判断结果，输出不同语句 if(flag){ //登录成功 System.out.println(&quot;登录成功！&quot;); }else{ System.out.println(&quot;用户名或密码错误！&quot;); } } /** * 登录方法 */ public boolean login(String username ,String password){ if(username == null || password == null){ return false; } //连接数据库判断是否登录成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; //1.获取连接 try { conn = JDBCUtils.getConnection(); //2.定义sql String sql = &quot;select * from user where username = &apos;&quot;+username+&quot;&apos; and password = &apos;&quot;+password+&quot;&apos; &quot;; System.out.println(sql); //3.获取执行sql的对象 stmt = conn.createStatement(); //4.执行查询 rs = stmt.executeQuery(sql); //5.判断 /* if(rs.next()){//如果有下一行，则返回true return true; }else{ return false; }*/ return rs.next();//如果有下一行，则返回true } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,stmt,conn); } return false; }​ /** * 登录方法,使用PreparedStatement实现 */ public boolean login2(String username ,String password){ if(username == null || password == null){ return false; } //连接数据库判断是否登录成功 Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; //1.获取连接 try { conn = JDBCUtils.getConnection(); //2.定义sql String sql = &quot;select * from user where username = ? and password = ?&quot;; //3.获取执行sql的对象 pstmt = conn.prepareStatement(sql); //给?赋值 pstmt.setString(1,username); pstmt.setString(2,password); //4.执行查询,不需要传递sql rs = pstmt.executeQuery(); //5.判断 /* if(rs.next()){//如果有下一行，则返回true return true; }else{ return false; }*/ return rs.next();//如果有下一行，则返回true } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,pstmt,conn); } return false; } } ​​ 5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作​ 1. 可以防止SQL注入​ 2. 效率更高 抽取JDBC工具类 ： JDBCUtils* 目的：简化书写 * 分析： 1. 抽取注册驱动 2. 抽取一个方法获取连接对象 * 需求：不想传递参数（麻烦），还得保证工具类的通用性。 * 解决：配置文件 jdbc.properties url= user= password= 3. 抽取一个方法释放资源 package utils; import java.io.FileReader; import java.io.IOException; import java.net.URL; import java.sql.*; import java.util.Properties; public class jdbcutils { private static String url; private static String user; private static String password; private static String driver; static { // 读取资源文件获取值 // 1.Properties try { Properties pro =new Properties(); // 获取src路径下的方式 // ClassLoader classLoader = jdbcutils.class.getClassLoader(); // URL res = classLoader.getResource(&quot;jdbc.properties&quot;); // String path =res.getPath(); // System.out.println(path); // 2.加载文件 pro.load(new FileReader(&quot;src/jdbc.properties&quot;)); // pro.load(new FileReader(path)); url = pro.getProperty(&quot;url&quot;); user = pro.getProperty(&quot;user&quot;); password = pro.getProperty(&quot;password&quot;); driver =pro.getProperty(&quot;driver&quot;); Class.forName(driver); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } }​ ​ // 获取连接，返回连接对象 public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url,user,password); } // 释放资源 public static void close(Statement stmt,Connection conn){ if (stmt!=null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } public static void close(Statement stmt,Connection conn,ResultSet rs){ if (rs!=null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (stmt!=null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } }​ ​","categories":[{"name":"jsp","slug":"jsp","permalink":"https://www.mo-yang.top/categories/jsp/"}],"tags":[{"name":"java工具类","slug":"java工具类","permalink":"https://www.mo-yang.top/tags/java%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"title":"spring之依赖注入数据","slug":"article5","date":"2020-03-10T10:24:07.000Z","updated":"2020-03-15T11:48:14.619Z","comments":true,"path":"2020/03/10/article5/","link":"","permalink":"https://www.mo-yang.top/2020/03/10/article5/","excerpt":"","text":"原本很认真的写，然而天有不测风云，更新个编辑器版本，我原本写的全没了，算了算了。 1.放在resource下的bean.xmlxquery123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; 依赖注入: dependency injection Ioc的作用 降低程序的依赖 依赖关系的管理交给spring维护 在当前类需要用到其他类的对象，由spring提供，需要再配置文件说明 依赖注入: 能注入的数据，三类： 基本类型和string 其他bean类型（在配置文件或者注解配置过的bean） 复杂类型/集合类型 注入方式: 1.使用构造函数 2.使用set 3.使用注解提供 构造函数注入 使用constructor-arg type：用于注入的数据的数据类型 index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引的位置从0开始 name：用于指定给构造函数中制定名称的参数赋值 value：提供基本类型和string类型的数据 ref：用于指定其他的bean类型数据。 优势： 获取bean对象时，注入数据是必须的操作 弊端： 如果用不到这些数据，也必须提供。 &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"text\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; --set方法注入 name：用于指定注入时调用的set方法名称 value：提供基本类型和string类型的数据 ref：用于指定其他的bean类型数据。 优势： 创建对象没有明确的限制，可以直接用默认构造函数 弊端： 如果某个成员必须有值，则获取对象时set方法没有执行 &lt;bean id=\"accountService2\" class=\"com.itheima.service.impl.AccountServiceImpl2\"&gt; &lt;property name=\"name\" value=\"test\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"21\"&gt;&lt;/property&gt; &lt;property name=\"birthday\" ref=\"now\"&gt;&lt;/property&gt; &lt;/bean&gt; 集合类型注入 用于给list结构注入的标签由 list array set 用于给map结构集合注入 map props 结构相同，标签可以互换 &lt;bean id=\"accountService3\" class=\"com.itheima.service.impl.AccountServiceImpl3\"&gt; &lt;property name=\"myStrs\"&gt; &lt;array&gt; &lt;value&gt;AAAAAA&lt;/value&gt; &lt;value&gt;bbbb&lt;/value&gt; &lt;value&gt;cccc&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"myList\"&gt; &lt;list&gt; &lt;value&gt;AAAAAA&lt;/value&gt; &lt;value&gt;bbbb&lt;/value&gt; &lt;value&gt;cccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;set&gt; &lt;value&gt;AAAAAA&lt;/value&gt; &lt;value&gt;bbbb&lt;/value&gt; &lt;value&gt;cccc&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;map&gt; &lt;entry key=\"testa\" value=\"bbbb\"&gt;&lt;/entry&gt; &lt;entry key=\"testb\" value=\"bbbb\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;props&gt; &lt;prop key=\"testc\"&gt;cccc&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; --把对象的创建交给spring来管理-- --spring对bian的管理细节 1.创建bean的三种方式 2.bean的作用范围 3.bean的生命周期 --1.使用默认构造函数 使用bean标签，配以id和class属性之后，没有其他属性和标签时，采用的就是默认构造函数， 如果类中没有默认构造函数，则对象无法创建 &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt;--&gt; --2.使用工厂中的方法创建对象，或者使用某个类中的方法创建对象，并存入spring容器 &lt;bean id=\"instanceFactory\" class=\"com.itheima.factor.IntanceFactor\"&gt;&lt;/bean&gt; &lt;bean id=\"accountService\" factory-bean=\"instanceFactory\" factory-method=\"getAccouhntService\"&gt;&lt;/bean&gt; --使用工厂中的静态方法创建对象 &lt;bean id=\"accountService\" class=\"com.itheima.factor.StaticFactory\" factory-method=\"getAccouhntService\"&gt;&lt;/bean&gt; bean的作用范围调整 bean标签的scope属性: 取值: singleton 单例(默认值) prototype 多例的 request 作用于web应用的请求范围 session 作用于web应用的会话范围 global-session 集群环境的会话范围(全局会话范围),当不是集群环境时，就是session --bean对象的生命周期 单例对象 生命周期和容器相同 多例对象 使用对象时候创建，只要是在使用过程中就一直活着， java垃圾回收器来进行回收 &lt;/beans&gt; 2.Client.javapgsql123456789101112131415161718192021222324252627282930313233343536package com.itheima.ui;//import com.itheima.dao.IAccountDao;import com.itheima.service.IAccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 模拟一个表现层，用于调用业务层 */public class Client &#123; public static void main(String[] args) &#123; //1.获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// ApplicationContext ac = new FileSystemXmlApplicationContext(\"C:\\\\Users\\\\zhy\\\\Desktop\\\\bean.xml\"); //2.根据id获取Bean对象// IAccountDao adao = ac.getBean(\"accountDao\",IAccountDao.class);// IAccountService as = (IAccountService)ac.getBean(\"accountService\");// as.saveAccount();// IAccountService as = (IAccountService)ac.getBean(\"accountService2\");// as.saveAccount(); IAccountService as = (IAccountService)ac.getBean(\"accountService3\"); as.saveAccount(); //--------BeanFactory----------// Resource resource = new ClassPathResource(\"bean.xml\");// BeanFactory factory = new XmlBeanFactory(resource);// IAccountService as = (IAccountService)factory.getBean(\"accountService\");// System.out.println(as); &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"https://www.mo-yang.top/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.mo-yang.top/tags/spring/"}]},{"title":"浅谈http协议","slug":"article4","date":"2020-03-09T01:52:56.000Z","updated":"2020-03-15T11:47:20.236Z","comments":true,"path":"2020/03/09/article4/","link":"","permalink":"https://www.mo-yang.top/2020/03/09/article4/","excerpt":"","text":"HTTP 超文本传输协议 Hyper Text Transfer Protocol 当我们在浏览器的地址栏输入一个地址的时候，就能够访问服务器的某个页面 这个过程本身就是两个应用程序之间的交互，一个应用程序是浏览器，另一个应用程序是服务器。 协议是什么？ 协议就是不同的应用程序之间按照事先做好的约定进行的通信。 这样就能互相读懂对方的意思。 浏览器和WEB服务器之间，使用的就是一种叫做HTTP的协议。 这样是BS (Browser Server )架构模型的基础 请求消息请求消息 由 请求行，请求头部，空行和请求数据4部分组成 1.请求行格式：请求方式 资源路径 HTTP版本号举例：GET/test.html HTTP/1.1请求方式：POST,HEAD,OPTIONS,DELETE,TRACE,PUT 2.请求头 请求头部信息提供了如下信息:Host: 主机名User-Agent: 浏览器基本资料Accept: 浏览器能够识别的响应类型Accept-Language: 浏览器默认语言Accept-Encoding: 浏览器能够识别的压缩方式Referer: 来路页面， /addHero 这个路径是通过addHero.html这个页面跳转过来的。Connecton：是否保持连接 3.请求数据​ post方法中，会把数据以key value形式发送请求 4.空行​ 发送回车符和换行符，通知服务器以下不再有请求头 响应消息响应信息由状态行，响应头，响应正文组成 1.状态行格式如下： HTTP-Version Status-Code Reason-Phrase CRLF 其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。 HTTP状态码当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。HTTP状态码的英文为HTTP Status Code。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 2.HTTP响应头响应头的方法 3.响应正文如图所示，在响应正文里就会是具体的html内容了。当然访问不同的页面，就不一定是html，有可能是css, js,甚至图片了。","categories":[{"name":"jsp","slug":"jsp","permalink":"https://www.mo-yang.top/categories/jsp/"}],"tags":[{"name":"jsp开发","slug":"jsp开发","permalink":"https://www.mo-yang.top/tags/jsp%E5%BC%80%E5%8F%91/"}]},{"title":"spring之获取容器","slug":"spring1","date":"2020-03-08T12:04:26.000Z","updated":"2020-03-15T11:49:50.317Z","comments":true,"path":"2020/03/08/spring1/","link":"","permalink":"https://www.mo-yang.top/2020/03/08/spring1/","excerpt":"","text":"spring:耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。 工厂模式:在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 解决程序耦合的思路 当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下： Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//此处只是一个字符串 此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运 行就不要想了，没有驱动不可能运行成功的）。 同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改 源码。 解决这个问题也很简单，使用配置文件配置。 工厂模式解耦 在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的 方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 1、存哪去？ 分析：由于我们是很多对象，肯定要找个集合来存。 这时候有 Map 和 List 供选择。 到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。 所以我们的答案就是 在应用加载时，创建一个 Map，用于存放三层对象。 我们把这个 map 称之为容器。 2、还是没解释什么是工厂？ 工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。 原来： 我们在获取对象时，都是采用 new 的方式。是主动的。 现在: 资源文件: beans.xml xml12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!-- 把对象创建交给spring管理--&gt; &lt;bean id=\"acccountService\" class=\"com.service.implement.AccountServiceImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; 运行Client.xml swift123456789101112131415161718192021222324252627282930313233343536373839package com.ui;import com.service.IAcountService;import com.service.implement.AccountServiceImpl;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;public class Client &#123; public static void main(String[] args) &#123;// IAcountService as = new AccountServiceImpl();// as.saveAccount();// ApplicationContext的三个常用实现类// ClassPathXmlApplicationContext 加载类路径下的配置文件，不在不能加载// FileSystemXmlApplicationContext 加载磁盘任意路径下的配置文件(必须有访问权限)// AnnotationConfigApplicationContext 用于读取注解创建容器// 两个接口引发的问题// ApplicationContext 采用立即加载的方式// 单例对象适用// BeanFactory : 采用延迟加载,id获取对象了，才会真正加载// 多例对象适用// 1.获取核心容器对象// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// ApplicationContext ac = new FileSystemXmlApplicationContext()// 2.根据id获取bean对象// IAcountService as = (IAcountService) ac.getBean(\"acccountService\");// System.out.println(as);// Resource resource = new ClassPathResource(\"bean.xml\");// BeanFactory factory =new XmlBeanFactory(resource); &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"https://www.mo-yang.top/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.mo-yang.top/tags/spring/"}]},{"title":"jsp入门学习成果","slug":"article3","date":"2020-03-06T08:32:37.000Z","updated":"2020-03-15T11:47:01.685Z","comments":true,"path":"2020/03/06/article3/","link":"","permalink":"https://www.mo-yang.top/2020/03/06/article3/","excerpt":"","text":"要相信，成功并不是成功者的专利，今天的你，不过是少了一点点机会加上毫不动摇的努力。努力让今天过得更有价值，才更有可能实现明天的美好。 接近一个暑假的学习jsp时光带给了我许多。 1.香水商店首先是一个神奇的香水商店，你的香水有毒啊！！！ 2.水果商店然后还有一个水果商店，鬼知道水果商店为什么卖洋葱和西红柿？？？ 3.个人博客第一代然后是上一个版本的个人博客，若大家有兴趣可以再去参观一下 http://47.95.13.8:8080/ceshi/ 呦呦鹿鸣，食野之苹 4.武汉加油想回学校啊，在家是真的无趣，想出门放飞自我，想出去逛吃……武汉加油啊,希望疫情赶紧过去吧。 山河无恙，人间皆安；冬已尽，春可期 http://47.95.13.8:8080/shiyan1_1/ 5.个人商城登陆模块实现完成于前几天。","categories":[{"name":"jsp","slug":"jsp","permalink":"https://www.mo-yang.top/categories/jsp/"}],"tags":[{"name":"jsp开发","slug":"jsp开发","permalink":"https://www.mo-yang.top/tags/jsp%E5%BC%80%E5%8F%91/"}]},{"title":"hexo的主题更换","slug":"article2","date":"2020-03-02T07:42:36.000Z","updated":"2020-03-02T08:08:10.103Z","comments":true,"path":"2020/03/02/article2/","link":"","permalink":"https://www.mo-yang.top/2020/03/02/article2/","excerpt":"","text":"上一篇文章，介绍了如何利用 hexo+github pages 搭建个人博客。那么这篇文章则以我的博客为例详细教你打造个性超赞博客的主题。 现如今用的人最多的是next这个主题，而本人在昨天发现一个神仙主题：Butterfly,It’s so beautiful . 这个主题不过有点废图， 提供2个自己搜图用的网站 https://wallroom.io/ https://www.pexels.com/ 安装在你的博客根目录里 git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 应用主题修改站点配置文件_config.yml，把主题改为Butterfly theme: Butterfly 配置配置文件说明站点配置文件config.yml是hexo工作目录下的主配置文件(还不知道是哪里的，自己google)butterfly.yml是Butterfly的配置文件。它需要你手动将主题目录下的 _config.yml 文件复制到 hexo 工作目录的source/data/butterfly.yml中。如果文件或者文件夹不存在，需要手动创建。*语言修改站点配置文件 _config.yml 默认语言是en 主题支持三种语言 ​ default(en)​ zh-CN (简体中文)​ zh-TW (繁体中文) 导航菜单配置menu: 首页: / || fa fa-home 归档: /archives/ || fa fa-archive 标签: /tags/ || fa fa-tags 分类: /categories/ || fa fa-folder-open 下面是butterfly的官方文档： https://jerryc.me/posts/21cfbf15/#%E5%BF%AB%E9%80%9F%E9%96%8B%E5%A7%8B 然后是本人的博客地址。 https://moyang-mu.github.io/ 总而言之，虽然今天有课，然本人昨天还是战斗到了12点半，从下午三点开始，除了吃饭时间基本都在调bug，今天早上也是调了一上午，真是身心俱疲啊。 还想说一句，就是我昨天因为默认开启了图片懒加载，但又没配置好，结果导致图片只有data-src属性，没有src属性，结果就是自然不能显示了。哎，想想都是泪，昨天晚上基本都是在看代码和博客还有官方文档中度过。","categories":[{"name":"框架","slug":"框架","permalink":"https://www.mo-yang.top/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.mo-yang.top/tags/hexo/"}]},{"title":"jsp的基本内置对象及作用","slug":"jsp1-1","date":"2020-03-02T07:22:45.000Z","updated":"2020-03-15T11:48:46.762Z","comments":true,"path":"2020/03/02/jsp1-1/","link":"","permalink":"https://www.mo-yang.top/2020/03/02/jsp1-1/","excerpt":"","text":"jsp的九大内置对象 bash1234jsp就本质相当于一个servlet，jsp的发明是为了简化我们对servlet的编写，&lt;%=%&gt;用于在service方法中直接输出，&lt;%%&gt; 其中编写的java代码将会在添加到service方法中实现，&lt;%!%&gt; jsp的重定向和请求转发 bash1234重定向是服务器将这个请求返回给浏览器，浏览器进行重新请求，区别在于，这次的请求的地址使用你上一次传回给他的。请求转发则是这个请求的内容等都不变，只不过把这个请求拿到另一个页面进行处理，处理完的结果在原页面显示。绝对路径:相对于项目的根路径，在路径前+上/相对路径:使用./或者什么都不加 由于cokkie部分版本不识别中文，导致可能出现中文乱码 bash1解决方案:使用两个工具类进行转码，URLEncoder在存储数据时候转码，URLDecoder在取出数据时进行转码。 Request在服务器请求资源原理解析 bash12 Requset在service中使用map集合一次性取出提交的表单数据的方法","categories":[{"name":"jsp","slug":"jsp","permalink":"https://www.mo-yang.top/categories/jsp/"}],"tags":[{"name":"jsp开发","slug":"jsp开发","permalink":"https://www.mo-yang.top/tags/jsp%E5%BC%80%E5%8F%91/"}]},{"title":"hexo的搭建","slug":"article","date":"2017-05-26T04:12:57.000Z","updated":"2020-03-02T07:47:47.725Z","comments":true,"path":"2017/05/26/article/","link":"","permalink":"https://www.mo-yang.top/2017/05/26/article/","excerpt":"","text":"本文使用的是在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。 第一部分 hexo的初级搭建还有部署到github page上，以及个人域名的绑定。(因为囊中羞涩，暂时未购买域名，嘿嘿) Hexo搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub 将hexo部署到GitHub 设置个人域名 发布文章 1.安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。Git教程 windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码sudo apt-get install git 2.安装nodejs Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。 windows：nodejs选择LTS版本就行了 安装完成后，检查一下 node -v npm -v 3. 安装hexo 前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 npm install -g hexo-cli 依旧用hexo -v查看一下版本 至此就全部安装完了。 接下来初始化一下hexo hexo init myblog 这个myblog可以自己取什么名字都行，然后 cd myblog //进入这个myblog文件夹 npm install 新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章和一些其他图片资源等 themes：主题 ** _config.yml: 博客的配置文件** hexo g hexo server 使用ctrl+c可以把服务关掉。 4. GitHub创建个人仓库首先，你先要有一个GitHub账户，去注册一个吧。 注册完登录后，在GitHub.com中看到一个New repository，新建仓库 创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。 点击create repository。 5. 生成SSH添加到GitHubgit config --global user.name &quot;yourname&quot; git config --global user.email &quot;youremail&quot; 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 可以用以下两条，检查一下你有没有输对 git config user.name git config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C &quot;youremail&quot; 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。 ssh -T git@github.com 6. 将hexo部署到GitHub 这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 npm install hexo-deployer-git --save hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西，将之前生成的静态页面等删除（与public文件有关）hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署到github上，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！ 7. 设置个人域名现在你的个人网站的地址是 yourname.github.io，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。 转载： https://blog.csdn.net/sinat_37781304/article/details/82729029","categories":[{"name":"框架","slug":"框架","permalink":"https://www.mo-yang.top/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.mo-yang.top/tags/hexo/"}]}]}